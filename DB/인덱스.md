# 인덱스

- 데이터베이스 테이블의 검색 속도를 향상시키기 위해 별도의 자료구조로 관리된다.
    - 인덱스를 적용하지 않은 컬럼은 조회 시 **모든 데이터**를 순차적으로 검색한다.
    - 인덱스 테이블은 데이터와 데이터의 위치(**PK**)를 관리하며, 이를 통해 빠르게 조회할 수 있다.
- 인덱스를 활용하면, 데이터를 조회하는 `SELECT` 외에도 `UPDATE`나 `DELETE`의 성능이 함께 향상된다.
    - 대상을 조회해야만 작업 할 수 있기 때문
- 인덱스의 자료 구조로는 해시 테이블, B+Tree 등이 있다.
    - 부등호를 이용해 검색하는 인덱스의 특성상, 보통 B+Tree를 사용한다.

#### B+Tree

- 모든 노드에 데이터를 저장하는 B-Tree를 개선시킨 자료구조.
- 리프 노드만 인덱스와 함께 데이터를 가진다.
    - 나머지 노드들은 인덱스만 가진다.
    - 리프 노드들은 `LinkedList`로 연결되어 있다.
      - InnoDB는 양방향으로 구현
- 데이터 노드(리프) 크기는 인덱스 노드(나머지)의 크기와 같지 않아도 된다.
- 무조건 리프 노드까지 도달해야 하는 단점이 있다.

## 적용 대상

- 규모가 작지 않은 테이블
- `INSERT`, `UPDATE`, `DELETE`가 자주 발생하지 않는 컬럼
- `JOIN`이나 `WHERE` 또는 `ORDER BY`에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

## 장점

- 테이블 조회 속도를 향상 시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.

## 단점

- 인덱스를 관리하기 위해 데이터베이스의 약 10%에 해당하는 저장 공간이 필요하다.
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하될 수 있다.
    - `INSERT`, `UPDATE`, `DELETE` 작업을 수행할 때마다 인덱스 테이블도 수정된다.
    - `UPDATE`와 `DELETE`는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 한다.
    - 따라서 `INSERT`, `UPDATE`, `DELETE` 가 빈번한 속성에 인덱스를 적용하면 인덱스 테이블 크기가 커지면서 성능이 저하된다.