# 상속

클래스를 확장하는 것으로 부모 클래스에 public 및 protected로 선언되어 있는 모든 변수와 메소드를 사용할 수 있다. 또 부모 클래스에 선언된 메소드를 오버라이딩 하거나 자식 클래스에서 새로운 변수와 메소드를 만들 수 있다.

먼저 접근 제어자에 대해 간단히 알아보자.

### 접근 제어자

* public: 모든 패키지에서 접근 가능
* protected: 같은 패키지 내, 상속받은 경우에만 접근 가능
* package-private: 접근 제어자가 없는 상태로 같은 패키지 내에서만 접근 가능
* private: 해당 클래스 내에서만 접근 가능

> 필드, 생성자, 메소드는 모든 접근 제어자를 선언할 수 있지만 클래스는 public과 package-private만 선언할 수 있다.

## 왜 상속을 사용할까?
애플리케이션 내에 공통부분을 각각의 클래스가 가지고 있을 경우 해당 내용을 변경할 때 모든 클래스를 수정해야 한다. 공통부분을 하나의 클래스로 잘 만들어 놓는다면 해당 클래스를 상속받아 이런 단점을 보완할 수 있다.

## super()

* 자식 클래스의 생성자를 호출하면 컴파일 시점에 자동으로 super()가 추가되어 부모 클래스의 기본 생성자가 호출된다.

* 부모 클래스에 기본 생성자가 없다면 자식 클래스의 생성자에 명시적으로 super()를 지정해 줘야한다.

* 자식 클래스 생성자의 가장 첫줄에 선언되어야 한다.

## 형 변환
일반적으로 여러 개의 값을 처리하거나, 매개 변수로 값을 전달할 때에는 보통 부모 클래스의 타입으로 보낸다. 이렇게 하지 않으면 배열과 같이 여러 값을 한번에 보낼 때 각 타입별로 구분해서 메소드를 만들어야 하는 문제가 생길 수 있다.

* 자식 클래스의 객체는 부모 클래스의 객체로 자동으로 형 변환이 되지만 반대의 경우 명시적으로 캐스팅해야 한다.

* 부모 클래스의 객체를 자식 클래스의 객체로 형 변환 하려면 실제 객체가 자식 클래스여야 가능하다.

## 오버라이딩 vs 오버로딩

오버라이딩

* 상속관계를 유연하게 활용하기 위해 사용.
* 부모 클래스의 메소드를 오버라이딩하면 자식 클래스의 메소드만 실행된다.
* 접근 제어자, 리턴 타입, 메소드 이름, 매개 변수 타입 및 개수가 모두 동일해야 한다.
 > 접근 제어자의 경우 접근 권환이 확장되는 경우는 문제없다. (private -> public)

메소드 오버로딩

* 동일한 역할을 하는 메소드의 확장.
* 메소드 이름은 같지만 매개변수의 타입과 개수, 순서가 달라야한다.

# 모든 객체는 Object를 상속
자바는 다중 상속을 받을 수 없지만, 여러 단계로 상속을 받을 수 있다. 모든 클래스는 Object 클래스를 상속 받아 클래스의 기본적인 행동을 정의한다.

## toString()
* Object 클래스의 메소드 중에서 가장 많이 사용
* getClass().getName() + ‘@’ + Integer.toHexString(hashCode())으로 표현되며 필요에 따라 재정의해서 사용한다.

## equals()
* Object의 equals()는 내부적으로 ==을 사용하기 때문에 객체의 동일성을 비교한다.
* 객체가 동등한지 비교하기 위해서는 조건에 따라 메소드를 재정의 해야 한다.

## hashCode()
* 객체의 메모리 주소를 16진수로 반환한다.
* 동일한 객체의 hashCode() 값은 동일해야 하기 때문에 equals() 메소드를 오버라이딩하면 hashCode() 메소드도 동일한 결과가 나오도록 오버라이딩 해야 한다.