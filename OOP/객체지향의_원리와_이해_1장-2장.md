# 이전 기술에서 시작된 신기술

스프링을 비롯한 모든 신기술은 갑자기 생긴 것이 아니다. 이전 기술의 어깨를 디딤돌 삼아 그 위에 이전 기술이 제시한 철학과 기법을 정반합의 논리로 정제하고, 거름 삼아 새로운 철학과 기법을 더해 나타나는 것이다.

따라서 이전 기술에 대해 자세하게 알진 못하더라도 그것들이 가진 의미에 대해서는 알고 있어야한다.

## 기계어

기계가 이해하는 유일한 언어로, 2진 숫자인 0과 1로만 표현된다. 다만 CPU마다 다르기 때문에 기종에 맞게 사용해야한다.

![Alt text](<이미지/기계어 실행.png>)

## 어셈블리어

기계어를 일상 용어로 표현한 언어로 니모닉과 기계어를 일대일로 매칭해서 사용한다. 사용하는 기계어가 CPU마다 다르기 때문에 어셈블리어 또한 CPU마다 다르다.

![Alt text](<이미지/어셈블리어 실행.png>)

> 니모닉<br>
어떤 것을 기억하는 데 쉽게 하도록 도움을 주는 것. 또는 쉽게 기억되는 성질

## C 언어

하나의 소스 파일을 각 기계에 맞는 컴파일러로 컴파일 하면 그에 맞는 기계어 목적 파일이 생성된다.

![Alt text](<이미지/C 언어 실행.png>)

어셈블리어 대비 이식성이 좋아졌지만 운영체제의 차이를 극복하지는 못했다.

## C++ 언어

C 언어에 객체 지향 개념을 도입한 언어다. 하지만 객체 없이도 프로그래밍이 가능하기 때문에 객체 지향 언어라기 보단 객체 지향 지원 언어라고 표현하는 것이 적절하다.

## 자바

진정한 객체 지향 언어로 자바에서는 클래스 외부에 존재할 수 있는 것은 아무것도 없다. 가상 머신을 사용해 한 번 작성한 코드를 어떤 운영체제나 기종에서도 사용할 수 있다.

![Alt text](<이미지/자바 실행.png>)

해당 기종용 JRE만 설치되어 있다면, 자바 컴파일러에 의해 생성된 목적 파일을 실행할 수 있다.

* JDK: 자바 개발 도구
* JRE: 자바 실행 환경
* JVM: 자바 가상 기계

JDK는 자바 소스 컴파일러인 javac.exe를 포함하며, JRE는 자바 프로그램 실행기인 java.exe를 포한한다. 이렇게 구분함으로써 각 운영체제별로 따로 설치파일을 준비해야 하는 불편함을 방지한다. 

### 메모리 사용 방식

아래는 프로그램이 메모리를 사용하는 방식을 간단하게 표현한 것으로 기계어를 포함한 모든 프로그래밍 언어의 공통된 메모리 사용방식이다.

![Alt text](<이미지/메모리 사용 방식.png>)

객체 지향 프로그램에서는 데이터 저장 영역을 다시 제 개의 영역으로 분할해서 사용한다.

![Alt text](<이미지/객체 지향 프로그램의 메모리 사용 방식.png>)

데이터 저장 영역이 T처럼 구분되어 T 메모리 구조라고 지칭할 수 있다.

# 자바와 절차적/구조적 프로그래밍

결국 자바도 객체 지향 이전에 프로그래밍 언어이기 때문에 이전의 프로그래밍 언어가 가진 프로그래밍 방식이 일부 녹아 있다. 따라서 절차적/구조적 프로그래밍 방식을 아는 것은 자바를 이해하는데 큰 도움이 된다.

### 절차적 프로그래밍

절차적 프로그래밍을 한마디로 표현하면 goto를 쓰지 말라는 것이다.

#### 왜 사용하지 못하게 한 걸까?

goto를 사용하게 되면 프로그램의 실행 순서가 인간이 이해하기에 너무 복잡해질 가능성이 있기 때문이다. 프로그램을 논리적으로 잘 구성한다면 굳이 goto를 사용하지 않아도 된다.

### 구조적 프로그래밍

구조적 프로그래밍은 함수를 사용하라는 것이다.

#### 함수 사용 시 장점

* 중복 코드를 한 곳에 모아서 관리할 수 있다.

* 함수 단위로 분리해서 이해하기 쉬운 코드를 작성할 수 있다.

> 함수와 메서드는 무엇이 다를까?<br>
같은 의미로 사용되지만, 굳이 차이점을 찾는다면 함수는 클래스나 객체와 아무 관계가 없지만 메서드는 반드시 클래스 정의 안에 존재해야 한다.

### main() 메서드: 메서드 스택 프레임

main() 메서드는 메모리에서 다음 순서로 실행된다.

1. JRE는 먼저 프로그램 안에 main()메서드가 있는지 확인한다.

2. main() 메서드의 존재가 확인되면 JRE는 JVM을 부팅한다.

3. JVM은 목적 파일을 받아 실행한다.

4. JVM은 java.lang 패키지와 작성한 클래스, 임포트 패키지를 메모리의 스태틱 영역에 배치한다.

5. 전처리 작업을 마치고 여는 중괄호를 만나 메모리 스택에 스택 프레임을 할당한다.

6. 파라미터 args를 스택 프레임 내부 지역 변수 배열에 할당된다.

7. main() 메서드의 처리 로직을 수행하고 닫는 중괄호를 만나면 스택 프레임이 소멸된다.

8. main() 메서드가 끝나면 JRE는 JVM을 종료하고 JRE도 운영체제 상의 메모리에서 사라진다.

### 블록 구문과 메모리

메서드 내부에 있는 블록 구문의 스택 프레임은 해당 메서드 스택 프레임 내부에 중첩되어 생성된다.

![Alt text](<이미지/내부 스택 프레임.png>)

이때 내부 스택 프레임은 외부 스택 프레임의 변수에 접근 가능하지만 역은 불가능하다.

### 메서드 호출과 메모리

메서드에서 다른 메서드를 호출하면 새로운 메서드 스택 프레임이 생성된다.

![Alt text](<이미지/메소드 스택 프레임.png>)

이 경우 각 메서드는 서로의 지역 변수에 접근할 수 없다.

메서드A 입장에서는 메서드B를 호출하기 전까지 메서드 B의 지역 변수는 존재하지 않고, 호출하고 나면 이미 사라져있기 때문에 당연히 사용할 수 없다.

메서드 B의 입장에서는 어떨까?

가능할 것 같지만 자바 스펙에서는 이를 금지한다. 추측할 수 있는 이유는 다음과 같다.

1. 메서드는 서로의 고유 공간이기 때문에 침입하지 않는 것이 이치에 맞기 때문이다.

2. 각 메서드에서 서로의 지역 변수에 접근하려면 정확한 주소를 알고 있어야 하는데 자바에서는 포인터를 사용할 수 없기 때문에 참조할 수 없다.