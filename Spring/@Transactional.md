# @Transactional

**AOP를 활용해서 선언적으로 트랜잭션 기능을 적용할 수 있다.**

* `@Transactional` 어노테이션을 특정 클래스나 메서드에 선언할 수 있다.
  * 트랜잭션 AOP는 `@Transactional` 어노테이션이 적용된 클래스에 대한 프록시를 만든다.
  * 생성된 프록시는 내부에 실제 객체를 참조하며, 실제 객체 대신 스프링 빈으로 등록된다.
* 클라이언트가 요청 시, 프록시는 해당 메서드가 트랜잭션이 적용되었는지 먼저 확인한다.
  * 트랜잭션이 적용된 메서드라면 트랜잭션을 시작한다.
  * 트랜잭션이 적용되지 않았다면 실제 객체에게 단순히 위임한다.
* `public`에만 적용할 수 있다.
  * 트랜잭션을 의도하지 않은 곳에도 과하게 적용되는 것을 방지하기 위해

## 주의사항

### 프록시 내부 호출

* 스프링은 의존관계 주입시 실제 객체 대신 프록시 객체를 주입해준다.
    * 따라서 실제 객체를 직접 호출하는 문제는 일반적으로 발생하지 않는다.
* 하지만 대상 객체의 내부에서 메서드를 호출하면 실제 객체를 직접 호출하게 된다.
  * 이렇게 되면 프록시를 거치지 않기 때문에 트랜잭션이 적용되지 않는다.
  * 트랜잭션이 적용된 메서드 내부에서 호출하는 것은 문제되지 않지만, 트랜잭션이 적용되지 않은 메서드 내부에서 트랜잭션이 적용된 메서드를 호출한다면 트랜잭션은 적용되지 않는다.

#### 해결 방법

* `AspectJ` 프레임워크를 사용해서 트랜잭션 처리 코드를 하드 코딩한다.
  * 프레임워크의 러닝 커브가 높고, 복잡한 단점이 있다.
* 별도의 클래스로 분리한다.
  * 내부 호출 대신, 분리한 클래스에 대한 프록시가 호출된다.

### 초기화 시점

* 초기화 코드(`@PostConstruct`)와 `@Transactional`을 함께 사용하면 트랜잭션이 적용되지 않는다.
  * 트랜잭션 AOP 이전에 초기화 코드가 실행되기 때문

#### 해결 방법

* `@EventListener(ApplicationReadyEvent.class)`로 대체하면 된다.
  * 스프링 빈부터 AOP 등 모든 준비가 끝난 후 실행된다.
