# 분산 환경에서 트랜잭션을 처리하는 방법

* 분산 환경에서는 서로 다른 데이터 베이스를 사용하기 때문에 단일 트랜잭션으로 처리할 수 없다.

# Two Phase Commit

**커밋 가능 여부를 판단한 후, 커밋하는 방식**

* 사용하는 DB 종류가 같아야 하며, 분산 트랜잭션을 지원해야한다.
* `Coordinator`를 통해 여러 DB 노드에 작업한 내용이 커밋 가능한지 확인한다.
  * 모든 노드가 커밋이 가능하다면, 한 번에 커밋을 수행한다. 
  * 커밋이 불가능한 노드가 있을 경우, 연관된 모든 노드에 중단 요청을 보낸다

# TCC(Try-Confirm/Cancel)

**분산된 REST 시스템들 간의 트랜잭션을 HTTP와 REST 원칙으로 접근하여 해결하는 방법**

* 별도의 staging table을 사용해서 자원을 선점한다.
* 먼저 `POST` 요청으로 예약하고, 모든 요청이 `Confirm`되면 `PUT` 요청으로 작업 수행
* (`POST`와 `PUT`으로 단계를 나누는 것이 어떤 장점을 가지는지 완벽히 이해하지 못했다... 추가 학습 필요)

# Saga Pattern

**이벤트, 메시지를 트리거로 사용하는 패턴**

* 순차적 로컬 트랜잭션으로 로컬 트랜잭션들이 순차적으로 업데이트를 수행한다.
* 트랜잭션 처리 도중 문제가 발생하면 보상 트랜잭션을 통해 이전 작업을 되돌린다.

## Orchestration based SAGA pattern

**중계자를 통해 분산 트랜잭션을 처리**

* 트랜잭션에 참가하는 모든 서비스는 중계자에 의해 점진적으로 트랜잭션을 수행한다.
  * 결과는 중계자에게 전달
* 마지막 트랜잭션이 끝나면 중계자가 종료되며, 전체 트랜잭션이 처리가 종료된다.
  * 도중에 트랜잭션이 실패하면 중계자에 의해 보상 트랜잭션 발생

#### 장점

* 트랜잭션에 참가하는 서비스가 다음과 같을 때 적합하다.
  * 서비스가 많고 복잡한 경우
  * 서비스들의 흐름을 제어할 수 있는 경우
* 역할이 명확하게 분리된다.
  * 복잡성이 줄어들고 테스트가 용이해진다.

#### 단점

* 중계자 서비스 생성에 대한 비용이 필요하다.
* 참여 서비스가 아닌 다른 외부 서비스로 인한 추가 실패 지점이 발생할 수 있다.

## Choreography based SAGA pattern

**중계자 없이 분산 트랜잭션을 처리**

* 로컬 트랜잭션이 처리되면 다음 서비스에게 직접 이벤트, 메시지를 전달한다.
* 도중에 문제가 발생하면 해당 서비스에서 실패에 대한 정보를 발행한다.
  * 이를 수신한 서비스는 보상 트랜잭션을 통해 롤백된다.

#### 장단점

* 추가 서비스(중계자)가 필요하지 않고, 간단한 워크플로우에 적합하다.
* 참가 서비스들이 어떤 명령을 수신하는지 파악하기 힘들다.
  * 새로운 서비스를 추가하는 것이 복잡하다.
* 서로의 명령을 소비하기 때문에 순환 종속성 문제가 발생할 수 있다.
* 전체 트랜잭션을 테스트하기 위해 모든 서비스가 실행되어야 하기 때문에 테스트가 어렵다.