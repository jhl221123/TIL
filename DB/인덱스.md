# 인덱스

**데이터를 더 빠르게 조회하기 위해 사용하는 자료구조** 

- 인덱스를 활용하면 필요한 데이터만 읽을 수 있다.
  - 이를 통해 랜덤 I/O를 줄일 수 있다.
- 일반적으로 B-Tree로 관리된다.
- 쓰기 작업의 속도를 희생하고, 읽기 작업의 성능을 향상하는 방법이다.
  - 단, 쓰기 작업 역시 조회를 동반하기 때문에 반드시 성능 저하가 발생한다고는 할 수 없다.

## B-Tree 인덱스

**Binary가 아닌 Balanced Tree**

- 루트, 브랜치, 리프 노드로 구성되어 있으며, 정렬 상태를 유지한다.
  - 모든 노드는 페이지 단위로 구분한다. 
  - 루트와 브랜치 노드는 자식 노드의 주소만 가진다.
  - 리프 노드는 클러스터링 인덱스를 가지고 있으며, 서로 `LinkedList`로 연결되어 있다.
- 자식 노드의 개수는 `페이지 크기 / 키 값의 크기`이다.
  - 이 때문에 B의 의미가 Balanced라고 할 수 있다.
  - 키 값이 커지면 페이지 수가 늘어나며, 이로 인해 디스크를 조회하는 횟수가 증가하게 된다.
- 일반적으로 카디널리티(선택도)가 높은 컬럼을 인덱스로 설정한다.
  - 단, 정렬 또는 그루핑을 위해 선택도가 좋지 않음에도 인덱스로 지정해 성능을 개선할 수도 있다.
- 일반적으로 데이터 1건 조회 비용은 인덱스가 테이블보다 **4~5배 크다**고 간주한다.
  - 옵티마이저는 조회 대상이 전체 테이블의 **20~25%를 넘어서면 테이블을 풀 스캔** 한다.

### 키 추가

- 인덱스를 추가할 때는 적절한 위치를 검색한 후 B-Tree의 리프 노드에 저장한다.
  - 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 있고 그렇지 않을 수도 있다.
  - 저장될 위치의 리프 노드가 가득 찼다면, 분리로 인해 처리 범위가 넓어진다.
- 테이블에 레코드를 추가하는 비용이 1이라고 가정하면, 대략 인덱스를 추가하는 비용은 1.5로 예측한다.
  - 비용의 대부분은 CPU 작업이 아니라 디스크에서 페이지를 읽고 쓰는 시간이다.

### 키 삭제 및 변경

- 삭제는 마킹을 통해 작업하며, 마킹된 인덱스 공간은 방치되거나 재활용된다.
- 인덱스 키 변경은 삭제 후 추가하는 방식으로 처리된다.
- 이 작업들 모두 버퍼를 활용해 지연처리할 수 있다.

### 키 검색

- **트리 탐색**: 루트 -> 브랜치 -> 리프 노드까지 이동하면서 비교 작업을 수행하는 것
  - `SELECT` 뿐만 아니라 `UPDATE`나 `DELETE`를 처리하기 전 조회할 때도 사용된다.
- 100% 일치하거나 앞부분만 일치하는 경우에만 사용할 수 있다.
  - 부등호를 통한 비교 조건에도 사용할 수 있다.
- 이미 변형된 값에 대해서는 인덱스를 적용할 수 없다.
  - 함수나 연산을 수행한 결과는 이미 인덱스에 존재하는 값이 아니다.

#### 레인지 스캔

- 가장 대표적인 접근 방식
- 루트 노드부터 시작해 브랜치 노드를 거쳐 리프 노드까지 도달하는 방식
- 도달한 곳이 필요한 레코드의 시작 지점이며, 이후 링크를 통해 탐색한다.

#### 인덱스 풀 스캔

- 처음부터 모든 리프노드를 순차적으로 탐색하는 방법
- 인덱스 레인지 스캔보다는 빠르지 않지만, 테이블 풀 스캔보다는 효율적이다.

#### 루스 인덱스 스캔

- 옵티마이저를 통해 불필요한 부분은 무시하고 스캔하는 방법
- 여러 가지 조건을 만족해야 한다.

### 다중 컬럼 인덱스

- 2개 이상의 컬럼을 포함하는 인덱스
- 하위 순서의 인덱스가 상위 순서의 인덱스에 의존적이다.
  - 순서에 따라 특정 쿼리에서 성능 차이가 많이 생길 수 있다.

### 스캔 방향

- 정순 스캔이 역순 스캔보다 30% 정도 빠르다.
  - 페이지 잠금이 인덱스 정순 스캔에 적합하기 때문
  - 페이지 내에서 인덱스 레코드가 단방향으로만 연결되어 있기 때문
- 따라서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 좋다.