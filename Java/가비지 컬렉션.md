# 가비지 컬렉션(GC)
자바의 메모리 관리 방법으로 JVM 내부 힙 영역에 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체를 모아 주기적으로 제거하는 프로세스를 말한다.

자바는 GC로 메모리를 관리하기 때문에 한정된 메모리를 효율적으로 사용할 수 있으며, 개발자는 메모리 문제에 대해 신경 쓰지 않고 개발에만 집중할 수 있다.

#### GC의 단점은?
* 메모리가 언제 해제되는지 정확하게 알 수 없어 제어하기 힘들다.
* GC가 너무 자주 실행되면 소프트웨어 성능 하락의 문제가 되기도 한다.
* 가비지 컬렉션이 동작하는 동안 Stop The World가 발생한다.

> Stop The World란?<br>
GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 현상. GC가 작동하는 동안 GC관련 Thread를 제외한 모든 Thread가 중지되기 때문에 발생한다.

## 가비지 컬렉션 대상
Reachability라는 개념을 적용해 대상을 구분한다.

* 해당 객체를 참조하는 객체가 있다면 Reachable로 구분

* 어떤 객체도 참조하지 않는다면 Unreachable로 구분하고 가비지 컬렉션의 대상이 된다.

## Mark And Sweep
다양한 GC에서 사용되는 기본적인 알고리즘으로 가비지 컬렉션의 대상 객체를 식별하고 제거한다.

![Alt text](이미지/mark-sweep-compact.gif)

### Mark
GC의 Root Space로부터 연결된 객체들을 찾아 각각 어떤 객체를 참조하고 있는지 확인하고 마킹한다.

### Sweep
참조하고 있지 않은 객체 즉, Unreachable 객체들을 힙 영역에서 제거한다.

### Compact
GC 대상 객체를 제거한 뒤, 분산된 객체들을 모으는 과정이다. GC종류에 따라 수행 여부가 다르다.

> GC의 Root Space란?<br>
힙 영역을 참조하는 메소드 영역, static 변수, 스택 영역, 네이티브 메소드 스택 영역이 이에 해당된다. Mark And Sweep 방식은 루트로부터 해당 객체에 접근이 가능한지 확인 후 Reachable 객체와 Unreachable 객체를 구분한다.

## 힙 영역의 메모리 구조
힙 영역은 동적으로 데이터가 저장되며, 가비지 컬렉션의 대상이 되는 공간이다.

#### 힙 영역의 전제 조건 2가지
* 대부분의 객체는 금방 접근 불가능한 상태(Unreachable)가 된다.
* 새로운 객체가 오래된 객체를 참조는 경우는 아주 적게 존재한다.

위 전제 조건으로 볼 때, 객체는 대부분 일회성이며 메모리에 오랫동안 남아있는 경우는 드물다. 따라서 객체의 생존기간에 따라 힙 영역을 Young 영역과 Old 영역으로 구분한다.

![Alt text](<이미지/힙 영역.png>)

### Young 영역
* 새롭게 생성된 객체가 할당되는 영역으로 해당 영역의 가비지 컬렉션을 Minor GC라고 부른다.

* 대부분의 객체가 금방 Unreachable 상태가 되기 때문에, 많은 객체가 Young 영역에 생성되었다가 곧 바로 사라진다.

### Old 영역
* Young영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역

* 해당 영역의 가비지 컬렉션을 Major GC 또는 Full GC라고 부른다.

* Young 영역보다 크며, 오래 사용되는 객체들이 모인 만큼 가비지는 적게 발생한다.

#### Old 영역이 Young 영역보다 크게 할당되는 이유는?
Young 영역은 객체들의 수명이 짧아 해당 영역에 오래 머물지 않는다. 반면, Old영역은 수명이 긴 객체들이 모여 오래 머물기 때문에 Young 영역보다 큰 공간이 필요하다.

#### 두 가지 영역으로 나뉜 힙 영역은 더욱 효율적인 GC를 위해 Young 영역을 다시 3가지 영역으로 나눈다. 

### Eden
* 새로 생성된 객체가 위치.
* 정기적인 GC 후 살아남은 객체들은 Survivor 영역으로 전달된다.

### Survivor 0 / Survivor 1
* 한 번 이상의 GC에서 살아남은 객체가 존재하는 영역
* Survivor 0 또는 Survivor 1, 둘 중 하나는 꼭 비어 있어야 한다.

## Minor GC 과정

![Alt text](<이미지/Minor GC.png>)

1. 처음 생성된 객체는 Young 영역 내부 Eden 영역에 위치

2. 객체가 계속 생성되어 Eden 영역이 가득 차면 Minor GC가 실행

3. Mark를 통해 Reachable 객체를 탐색하고 해당 객체들을 Survivor 0 영역으로 이동

4. Eden 영역의 Unreachable 객체의 메모리 해제

5. Survivor 0 영역으로 이동한 객체들은 age값이 1씩 증가

6. 다시 Eden 영역이 신규 객체들로 가득 차게 되면 minor GC가 발생하고, 살아남은 객체들은 Survival 1으로 이동한 후 age가 1씩 증가하게 된다.

7. 위 과정을 반복

> age 값이란?<br>
객체가 살아남은 횟수를 의미하는 값이며, Object Header에 기록된다. 만일 age 값이 임계 값에 도달하면 Old 영역으로 이동하는 Promotion이 발생한다.

## Major GC 과정

![Alt text](<이미지/Major GC.png>)

1. Young 영역 객체의 age가 임계값에 도달하게 되면, 해당 객체들은 Old 영역으로 이동하는데 이를 Promotion 이라 부른다.

2. 계속되는 Promotion에 의해 Old 영역의 공간이 부족하게 되면 Major GC가 발생되게 된다.

### Minor GC와 Major GC 차이점

||Minor GC|Major GC|
|---|---|---|
|대상|Young 영역|Old 영역|
|실행 시점|Eden 영역이 가득 찬 경우|Old 영역이 가득 찬 경우|
|실행 속도|빠르다|느리다|

## GC의 종류
애플리케이션의 지연 현상을 최적화하기 위해 다양한 GC가 개발되었으며, 설정을 통해 GC 방식을 선택해서 사용할 수 있다.

### Serial GC
서버의 CPU 코어가 1개일 때 사용하기 위해 개발된 가장 단순한 GC로, 보통 실무에서 사용하는 경우는 없다 

### Parallel GC 
Java 8의 디폴트 GC로 Serial GC와 기본적인 알고리즘은 같지만, Young 영역의 Minor GC를 멀티 쓰레드로 수행한다.

### Parallel Old GC
Parallel GC를 개선한 버전으로 Major GC도 멀티 쓰레드로 수행

### CMS GC (Concurrent Mark Sweep)
* 어플리케이션과 GC를 동시에 실행시켜 stop-the-world 시간을 최대한 줄이기 위해 고안된 방식
* GC 대상을 파악하는 과정이 복잡한 여러 단계로 수행되기 때문에 다른 GC 대비 CPU 사용량이 높다.

### G1 GC (Garbage First)
* Java 9 이상 버전의 디폴트 GC로 이전과 전혀 다른 방식인 Region이라는 개념을 새로 도입하여 사용
* 일일히 메모리를 탐색해 객체들을 제거하는 것이 아니라 메모리가 많이 차있는 Region을 인식해 영역별로 GC가 일어난다.
* 이전의 GC들은 정해진 위치로 순차적으로 이동했지만, G1 GC에서는 더욱 효율적이라고 생각하는 위치로 객체를 재할당한다.

> 예를 들어 Survivor1 영역에 있는 객체가 Eden 영역으로 할당하는 것이 더 효율적이라고 판단될 경우 Eden 영역으로 이동시킨다.

### Shenandoah GC
CMS가 가진 단편화, G1이 가진 pause의 이슈를 해결 (Java 12~)

### ZGC (Z Garbage Collector)
* 대량의 메모리 처리하기 위해 디자인 된 GC (Java 15~)
* G1 GC의 Region은 크기가 고정인데 비해, ZGC가 사용하는 ZPage는 2mb 배수로 동적으로 운영된다.
* ZGC는 힙 크기가 증가하더도 'stop-the-world'의 시간이 절대 10ms를 넘지 않는다.