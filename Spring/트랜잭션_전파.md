# 트랜잭션 전파

**내부 트랜잭션이 외부 트랜잭션에 참여하는 것**

* 스프링은 트랜잭션 전파의 이해를 돕기 위해 논리 트랜잭션과 물리 트랜잭션으로 구분한다.
  * 트랜잭션이 하나인 경우는 구분하지 않으며, 트랜잭션 진행 중 내부에 새로운 트랜잭션이 사용되는 경우 구분한다.
  * 논리 트랜잭션은 트랜잭션 매니저를 통해 사용하는 단위, 논리 트랜잭션들은 하나의 물리 트랜잭션으로 묶인다.
  * 물리 트랜잭션은 실제 데이터베이스에 적용되는 트랜잭션, 실제 커넥션을 통해 커밋, 롤백하는 단위이다.
* 트랜잭션 원칙
  * 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.
  * 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백된다.
  * **모든 트랜잭션 매니저를 커밋해야 물리 트랜잭션이 커밋된다.**

## 동작 원리

* 외부 트랜잭션 시작
  1. 트랜잭션 매니저: `DataSource` -> 커넥션 생성 -> `con.setAutoCommit(false)`
  2. 트랜잭션 매니저: 트랜잭션 동기화 매니저에 커넥션을 보관
  3. 트랜잭션 매니저: 트랜잭션 생성 결과를 `TransactionStatus`에 담아 반환
     * `isNewTransaction`을 통해 신규 트랜잭션 여부 확인 가능 -> 외부 트랜잭션은 신규 트랜잭션!
  4. 이후 로직들은 현재 스레드의 트랜잭션 동기화 매니저에 있는 **트랜잭션이 적용된 커넥션을 획득**해서 사용한다. 
* 내부 트랜잭션 시작
  1. 트랜잭션 매니저: 트랜잭션 동기화 매니저에 기존 트랜잭션이 존재하는지 확인
  2. 외부 트랜잭션이 이미 존재하기 때문에 해당 트랜잭션에 참여
     * 참여한다는 것은 실제로 아무것도 하지 않는 것을 의미!
     * 이미 외부에서 물리 트랜잭션(`con.setAutoCommit(false)`)을 시작했기 때문에 그대로 참여가 된다.
  3. 트랜잭션 매니저: 트랜잭션 생성 결과를 `TransactionStatus`에 담아 반환 -> 신규 트랜잭션 아님!
  4. 계속해서 트랜잭션 동기화 매니저에 존재하는 커넥션을 사용한다.
* 내부 트랜잭션 커밋
  * **트랜잭션 매니저는 신규 트랜잭션 여부에 따라 다르게 동작**한다!!
  * 내부 트랜잭션 로직이 끝나면 트랜잭션 매니저를 통해 트랜잭션을 커밋한다. 
  * 이때 **신규 트랜잭션이 아닐 경우, 실제 커밋을 호출하지 않는다.**
    * 실제 커밋 혹은 롤백을 호출할 경우, 물리 트랜잭션이 끝나기 때문
    * 물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 끝나면 안된다.
* 외부 트랜잭션 커밋
  * 외부 트랜잭션 로직도 끝나면 트랜잭션 매니저를 통해 트랜잭션을 커밋한다.
  * 외부 트랜잭션은 신규 트랜잭션이기 때문에 실제 커밋, 롤백을 호출한다.

### 핵심

* 트랜잭션 매니저에 커밋하는 것은 논리적 커밋, 실제 커넥션에 커밋하는 것은 물리적 커밋이라 할 수 있다.
* 트랜잭션 매니저에 커밋을 호출한다고해서 항상 실제 커넥션에 물리 커밋이 발생하는 것이 아니다.
  * 신규 트랜잭션일 경우에만 실제 커넥션을 사용해서 물리 커밋과 롤백을 수행한다.