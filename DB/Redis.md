# Redis

* 비관계형 데이터 베이스 관리 시스템(NoSQL)
* **Key, Value** 구조의 비정형 데이터를 저장하고 관리
* 데이터 베이스, 캐시, 메시지 브로커로 사용되는 인메모리 저장소
    * 캐시 서버: 매번 DB를 거치지 않고 저장된 값으로 바로 응답
      * Look aside cache, Write Back 패턴이 있다.

## 특징

- **Key, Value 구조**로 쿼리를 사용할 필요가 없는 NoSQL이다.
- 데이터를 메모리에서 처리하기 때문에 속도가 빠르다.
  - 성능이 `memcached` 와 비슷하다.
- 지속성을 보장하기 위해 데이터를 디스크에 저장할 수 있는 기능을 제공한다.
    - 서버가 내려가도 저장된 데이터를 다시 메모리에 로딩할 수 있다.
    - 데이터를 저장하는 방법은 크게 다음 두 가지가 있다.
        - `RDB(Snapshotting) 방식`: 주기적으로 메모리에 있는 내용 전체를 디스크로 옮기는 방식
            - `SAVE`: **blocking 방식**으로 순간적으로 Redis의 모든 동작을 정지시키고, 해당 시점의 snapshot을 디스크에 저장
            - `BGSAVE`: **non-blocking 방식**으로 별도의 프로세스를 띄운 후 명령어 수행 당시의 메모리 snaopshot을 디스크에 저장, Redis는 중단되지 않는다.
            - 장점 : 서버 재시작 시 snapshot만 로드하면 되기 때문에 재시작 시간이 빠르다.
            - 단점 : snapshot을 추출하는 시간이 오래 걸리며, 백업되지 않은 데이터는 유실된다.
        - `AOF(Append On File) 방식`: Redis의 모든 write/update 연산 자체를 모두 로그 파일에 기록하는 방식
            - 기본적으로 **non-blocking call**
            - 서버가 재시작할 때 기록된 write/update Operation을 순차적으로 재실행해 데이터를 복구한다.
            - Operation이 발생할 때마다 로그를 기록하기 때문에 최신 상태를 유지할 수 있다.
            - 장점 : 로그 파일에 대해 append만 하기 때문에 쓰기 속도가 빠르며, 어느 시점에 서버가 다운되더라도 데이터 유실이 발생하지 않는다.
            - 단점 : 로그 데이터 양이 과대하며, 복구 시 저장된 write/update Operation을 다시 수행하기 때문에 재시작 속도가 느리다.
        - 두 가지 방식을 혼용하는 것을 권장
            - 주기적으로 snapshot으로 백업하고 다음 snapshot까지의 저장을 AOF 방식으로 수행
            - 서버가 재시작할 때 백업된 snapshot을 로드, 소량의 AOF 로그만 재수행하면 되기 때문에 재시작 시간을 절약하고 데이터의 유실을 방지할 수 있다.
- Value가 **다양한 자료 구조를 지원**한다.
    - **String**: 가장 일반적인 key, value 구조의 형태
    - **Sets**: String의 집합. 하나의 value에 여러 데이터를 넣는 구조(key: set 이름, value: set에 포함되는 String들)
    - **Sorted Sets**: set에 가중치를 나타내는 필드인 `score`를 추가해서 정렬된 Set 구조를 만든다. 명령어로 특정 범위 및 최상단 데이터를 조회할 수 있다.
    - **Hashes** : 하나의 value에 **field, string 쌍으로 이루어진 테이블을 저장**하는 자료 구조. field는 RDBMS의 PK와 같다.
    - **Lists**: **양방향 linked list**와 유사한 특성을 가진다. 양 끝 데이터 삽입, 삭제는 빠르고 인덱스를 사용한 중간 데이터 삽입, 삭제는 느리다.
- **Single Threaded**다.
    - 한 번에 하나의 명령만 처리할 수 있다.
    - 중간에 처리 시간이 긴 명령어가 들어오면 그 뒤에 명령어들은 모두 앞에 있는 명령어가 처리될 때까지 대기가 필요하다.
        - 하지만 get, set 명령어의 경우 초당 10만 개 이상 처리할 수 있을 만큼 빠르다.

## 주의 사항

- 서버에 장애가 발생했을 경우에 대비해야 한다.
    - 인메모리 데이터 저장소의 특성상, 서버에 장애가 발생했을 경우 데이터 유실이 발생할 수 있기 때문
- 인메모리 저장소이기 때문에 당연하게도 메모리 관리가 중요하다.
- 싱글 스레드 기반으로 동작하기 때분에 처리 시간이 오래 걸리는 요청, 명령은 피해야 한다.
- 만료 정책
    - Redis는 데이터에 대해 생명주기를 정해서 일정 시간이 지나면 자동으로 삭제되게 할 수 있다.
    - Redis가 expire된 데이터를 삭제하는 정책은 내부적으로 **Active**와 **Passive** 두 가지 방법을 사용한다.
        - `Active`: 클라이언트가 expired된 데이터에 접근할때, 만료 여부를 확인하고 지우는 방식
        - `Passive`: 주기적으로 Key들을 랜덤으로 일부만(100개) 스캔해서 지우는 방식
        - expired time이 지난 후 클라이언트에 의해 접근되지 않은 데이터는 Passive 방식으로 지워져야 한다.
        - 하지만 이 경우, 전체 데이터를 스캔하는 것이 아니기 때문에 expired되었으나 지워지지 않는 Garbage 데이터가 존재할 수 있는 원인이 된다.