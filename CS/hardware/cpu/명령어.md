# 명령어

**컴퓨터를 동작시키는 정보**

* 연산 코드와 오퍼랜드(피연산자)로 구성된다.
* CPU마다 명령어의 종류가 다르지만, 기본적으로 4가지 유형이 있다.
  * 데이터 전송: 메모리, 레지스터 등과 상호작용 (MOV, PUSH/POP...)
  * 산술/논리 연산: 데이터 연산 작업
  * 제어 흐름 변경: 명령어 실행 흐름 제어 (JUMP, CALL, RETURN, HALT...)
  * 입출력 제어: 입출력 장치와 상호작용 (READ, WRITE...)

## 주소 지정 방식

**오퍼랜드에 데이터를 표현하는 방식**

* 오퍼랜드에 직접 데이터를 저장하거나 주소를 저장한다.
* 주소를 저장해 표현 가능한 데이터 크기를 늘릴 수 있으며, 이때의 주소를 유효주소라고 한다.

### 즉시 주소 지정 방식

* 연산에 필요한 데이터를 오퍼랜드에 직접 명시하는 방식
* 메모리나 레지스터에서 연산에 필요한 데이터를 조회하는 과정이 없어 빠르다.
* 표현 가능한 데이터 크기에 제한이 있다.

### 직접 주소 지정 방식

* 오퍼랜드에 유효 주소를 직접 명시하는 방식
* 표현 가능한 데이터 크기는 증가했지만, 표현 가능한 주소 크기가 연산 코드의 크기만큼 제한된다.
* 연산에 필요한 데이터를 유효 주소에서 가져와야 한다.

### 간접 주소 지정 방식

* 오퍼랜드에 유효 주소의 주소를 명시하는 방식
* 데이터와 주소 크기 모두 증가
* 데이터를 조회하기 위해 두 번의 메모리 접근이 필요하다.

### 레지스터 주소 지정 방식

* 오퍼랜드에 레지스터의 주소(유효주소)를 명시하는 방식
* 직접 주소 지정 방식과 원리는 동일
* 메모리가 아니라 레지스터에 접근하기 때문에 직접 주소 지정 방식보다 빠르다.

### 레지스터 간접 주소 방식

* 오퍼랜드에 유효 주소가 저장된 레지스터의 주소를 명시하는 방식
* 유효 주소는 메모에 존재한다.
* 간접 주소 지정 방식보다 빠르다.

## 병렬 처리 기법

**CPU 자원을 효과적으로 사용하기 위해 명령어를 효율적으로 처리하는 기법**

### 명령어 파이프라인

**명령어 처리 과정을 구분하고, 서로 다른 단계를 곂쳐서 실행하는 기법**

|      | t0    | t1    | t2  | t3 |t4|t5|
|------|-------|-------|-----|----|---|---|
| cmd1 | 인출    | 해석    | 실행  | 저장 |||
| cmd2 || 인출    | 해석  | 실행 | 저장 ||
| cmd3 |||  인출 | 해석  | 실행 | 저장 |

* 성능상 이점이 있지만 특정 상황에선 위험이 존재한다.
  * 데이터 위험: 명령어 간 데이터 의존성이 있는 경우
    * ex) cmd2를 실행하기 위해 cmd1의 결과가 필요한 경우
  * 제어 위험: 분기 등으로 흐름이 변경되는 경우
    * ex) cmd1 실행 과정에서 분기가 발생하면 cmd2(인출, 해석), cmd3(인출) 과정이 무의미해진다.
  * 구조적 위험: 서로 다른 명령어가 ALU, 레지스터 등을 동시에 사용하려는 경우

### 슈퍼 스칼라

**여러 개의 파이프라인을 이용하는 기법**

|      | t0    | t1    | t2  | t3 |t4|t5|
|------|-------|-------|-----|----|---|---|
| cmd1 | 인출    | 해석    | 실행  | 저장 |||
| cmd2 | 인출    | 해석    | 실행  | 저장 |||
| cmd3 || 인출    | 해석  | 실행 | 저장 ||
| cmd4 || 인출    | 해석  | 실행 | 저장 ||
| cmd5 |||  인출 | 해석  | 실행 | 저장 |
| cmd6 |||  인출 | 해석  | 실행 | 저장 |

* 멀티 스레드 CPU 처럼 여러 개의 명령어를 동시에 처리할 수 있는 구조에서 사용 가능하다.
* 처리 속도가 항상 파이프라인 개수에 비례하는 것은 아니며 위험을 피하기 위해 고도로 설계가 필요하다.

### 비순차적 명령어 처리

**명령어를 효율적인 순서로 변경하여 처리하는 기법**

* 의존성이 없는 명령어를 먼저 실행함으로써 파이프라인이 멈추는 것을 방지한다.
* 파이프라이닝 기법과 함께 사용하여 서로 보완한다.

## 명령어 집합(ISA)

**CPU가 이해할 수 있는 명령어 모음**

* 명령어의 기본적인 구조는 유사하지만, CPU 제조사와 종류에 따라 차이가 있다.
  * 같은 소스 코드라도 ISA가 다르면 CPU가 이해하는 어셈블리어도 달라진다.

### CISC

**복잡한 명령어 집합을 활용하는 컴퓨터**

* 복잡하고 다양한 명령어를 활용한다.
  * 상대적으로 적은 수의 명령어로 프로그램을 실행할 수 있다.
  * 메모리를 최대한 절약하며 개발해야할 때 효과적이다.
* 가변 길이 명령어를 사용한다.
  * 명령어의 규격화가 어려워 파이프라이닝이 어렵다.

### RISC

**단순한 명령어 집합을 활용하는 컴퓨터**

* 단순하고 규격화된 명령어를 활용한다.
  * 메모리 접근 명령어가 load, store 두 개로 제한할 만큼 최소화를 추구한다.
  * 메모리 접근을 단순화, 최소화하는 대신 레지스터를 적극 활용한다.
  * 파이프라이닝하기 쉽다.
* 사용 가능한 명령어의 종류가 CISC보다 적다.
  * 같은 기능을 수행하는 프로그램도 CISC보다 더 많은 명령어가 필요하다.