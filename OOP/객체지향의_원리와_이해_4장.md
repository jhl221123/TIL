# 자바가 확장한 객체 지향

객체 지향의 4대 특성을 넘어 **자바**가 객체 지향을 확장하기 위해 사용하는 키워드와 개념을 살펴보자.

## 추상 메서드와 추상 클래스

추상 메서드란 선언부는 있는데 구현부가 없는 메서드를 말하며, 추상 메서드를 하나라도 가지고 있는 클래스는 반드시 추상 클래스로 선언해야한다.

추상 클래스로 선언하면 객체를 생성할 수 없기 때문에 메서드의 선언부만 존재할 수 있다.

상속 관계에서 상위클래스는 상위 분류라고 표현할 수 있다. 만약 상위 분류에서 구체적인 행위를 지정할 수 없지만, 해당 기능이 반드시 있어야 할 때 추상 메서드를 사용해서 하위 클래스에게 구현을 위임할 수 있다. 하위 클래스는 상위 클래스의 추상 메서드를 반드시 재정의 해야한다.

## 생성자

클래스의 인스턴스를 만들 때 사용하는 **메서드**다.
생성자가 하나도 없으면 컴파일 시점에 자동으로 기본 생성자가 생성되고, 하나라도 존재하면 기본 생성자는 자동으로 생성되지 않는다.

## static 블록

클래스 로딩 시점에 실행되며, 프로그램 실행 과정동안 단 한 번만 실행된다. 클래스는 다음 세 가지 경우에서 동적으로 로딩된다.

* 클래스의 정적 속성을 사용할 때
* 클래스의 정적 메서드를 사용할 때
* 클래스의 인스턴스를 최초로 만들 때

#### 클래스는 왜 동적으로 로딩할까?

클래스 로더에 의해 로딩된 클래스들은 JVM 내부 메서드 영역에 배치된다. 해당 영역도 결국 메모리이며, 메모리는 최대한 늦게 사용하고 빨리 반환하는 것이 정석이다.

한번 로딩된 클래스는 프로그램이 끝날 때까지 메모리에서 내려오지 않지만, 최대한 늦게 로딩함으로써 메모리 사용을 최대한 늦추기 위해 클래스를 동적으로 할당한다.

#### 객체를 위한 {} 블록

static 블록이 클래스를 위한 블록이었다면, {} 블록은 객체를 위한 블록이다. {} 블록은 객체가 생성될 때마다 실행되며, 생성자가 실행되기 전에 먼저 실행된다.

## final

final은 불변을 의미하며 클래스, 변수, 메서드에 적용할 수 있다.

#### 클래스

final이 클래스 레벨에 사용되면, 더 이상 확장 불가능한 클래스가 된다. 즉, 상속을 할 수 없고 하위 클래스를 만들 수 없다. 대표적인 final 클래스로는 String이 있다.

#### 변수

final을 사용한 변수는 더 이상 변경할 수 없는 상수가 된다. 변수 종류에 따른 초기화 방법은 다음과 같다.

|종류|방법|
|---|---|
|클래스 변수|선언 시, static 블록|
|인스턴스 변수|선언 시, 생성자 또는 인스턴스 블록|
|지역 변수|선언 시, 최초의 초기화|

자바는 final을 사용해서 상수를 표현하기 때문에 const를 예약어로 등록해두고 사용하지 못하게 한다.

#### 메서드

final 메서드는 더 이상 재정의하지 못한다. 따라서 하위 클래스는 정의된 메서드를 그대로 사용해야한다.

## instanceof

해당 객체가 특정 클래스의 인스턴스인지 확인해주는 연산자다. 객체 참조 변수의 타입이 아니라 실제 객체를 기준으로 처리한다.

instanceof 연산자를 사용해서 클래스의 상속 관계뿐만 아니라 인터페이스의 구현 관계에 대해서도 확인할 수 있다.

## package

문제의 영역을 개발자가 정의하는 단위로 이름 공간을 나누어 관리한다. 서로 다른 패키지에 동일한 이름을 가진 파일들은 다른 파일로 인식된다. 

## interface와 implements

인터페이스는 public 추상 메서드와 public 정적 상수만 가질 수 있다. 아무런 키워드를 사용하지 않으면 public, abstract, static, final을 자동으로 붙여준다.

## this

객체 스스로를 지칭하는 키워드로 지역 변수와 인스턴스 변수가 이름이 같을 때 구분하거나 매개 변수로 객체 자체를 전달할 때 사용할 수 있다.

## super

바로 위의 상위 클래스를 지칭하는 키워드로 하위 클래스의 생성자에 자동으로 생성된다. 상위 클래스에 기본 생성자가 없는 경우에는 매개 변수와 함께 명시해야 한다.

## JVM 내부 메서드의 위치

동일한 클래스의 인스턴스들은 서로 다른 상태를 가질 수 있지만 행위는 변하지 않는다. 따라서 메서드를 한 곳에서 관리하면 객체마다 메서드를 가지고 있지 않아도 되며, 메모리를 낭비하지 않을 수 있다.

```java
class Bird {
    void fly() {
        System.out.println("Fly!");
    }

public class Main {
    public static void main(String[] args) {
        Bird abird = new Bird();
        abird.fly();
    }
}
}
```

fly() 메서드에 static 키워드가 추가되며, 메서드 호출 시 this를 매개 변수로 전달하게 된다.

메모리 구조는 다음과 같다.

![Alt text](<이미지/메모리 내 메서드 위치.png>)