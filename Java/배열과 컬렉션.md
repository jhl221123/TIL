# 배열

하나의 변수에 여러 개의 값을 넣을 수 있는 자료 구조로, 인덱스는 0번지부터 시작하며 지정 된 범위를 벗어나 접근하면 예외가 발생한다.

```java
int[] array = new int[7];
```

|위치|0|1|2|3|4|5|6|
|:---|---:|---:|---:|---:|---:|---:|---:|
|값|0|0|0|0|0|0|0|

* new 또는 중괄호를 사용해서 생성할 수 있으며, 한 번 지정한 크기는 변경할 수 없다.

* 중괄호를 사용해서 생성할 경우, 변수 선언과 동시에 초기화해야 한다.

* 배열을 초기화만 하면 해당 자료형의 기본값이 지정된다. 따라서 참조 자료형의 경우 null safe 하도록 각각의 값을 초기화하는 것이 좋다.

### 2차원 배열

```java
int[][] twoDim;
```

* 앞에 있는 대괄호가 1차원, 뒤에 있는 대괄호가 2차원이다.

* 2차원 배열에서 1차원 배열의 위치만 지정할 경우 해당 배열의 2차원 배열이 반환된다.

```java
twoDim = new int[2][];
twoDim[0] = new int[3];
twoDim[1] = new int[2];
```

1차원 배열의 크기만 지정해 두고 2차원 배열의 크기를 서로 다르게 지정할 수도 있다.

#### 향상된 for 루프

JDK 5부터 배열과 컬렉션을 대상으로 for 루프를 편리하게 사용할 수 있도록 개선되었다.

```java
for(int[] dimArray : twoDim) {
	for(int data : dimArray) {
		System.out.println(data);
	}
}
```


배열의 위치 정보가 필요한 경우에는 기존의 for 루프가 유리하고, 값만 처리한다면 향상된 for 루프를 사용하는 것이 유리하다.


# 컬렉션

목록성 데이터를 처리하는 자료 구조로 여러 데이터를 저장하기 위해 사용한다. 자바에서 제공하는 자료 구조는 크게 다음과 같다.

![Alt text](<이미지/자바 자료 구조.png>)

## List
컬렉션을 확장한 다른 인터페이스와 List 인터페이스의 가장 큰 차이점은 순서가 중요하다는 점이다. 대표적인 구현 클래스로는 ArrayList, Vector, Stack, LinkedList가 있다.

### ArrayList

 네 가지 중 가장 많이 사용되며, 생성자는 다음과 같다.

|생성자|설명|
|---|---|
|ArrayList()|저장 공간이 10개인 객체를 생성|
|ArrayList(int initialCapacity)|저장 공간을 매개 변수로 받는다.|
|ArrayList(Collection<? extends E> c)|컬렉션 객체를 매개 변수로 받는다.|

저장되는 값이 저장 공간의 크기보다 클 경우 ArrayList 내부에서 크기를 늘이는 작업이 수행된다. 이 과정으로 애플리케이션 성능에 영향을 줄 수 있기 때문에 초기 크기를 어느 정도 예측해서 지정해 두는 것이 좋다.

마지막 생성자의 경우 매개 변수로 받은 객체는 Deep Copy로 생성된다.

> * Deep copy와 Shallow copy<br> Deep copy는 객체의 모든 값을 복사하여 전달하는 것으로 원본에 영향을 미치지 않는다. 반대로 Shallow copy는 원본 객체의 주소 값을 할당하기 때문에 전달 받은 곳에서 값을 변경하면 원본 객체의 값도 변경된다.

해당 클래스가 제공하는 메소드를 통해 값을 추가하고 삭제하는 등 다양한 기능을 사용할 수 있다.

### Vector

* Vector는 기능적으로 ArrayList와 거의 동일하다.

* Thread safe 여부에 차이가 있으며, Vector는 Thread safe 하지만 ArrayList는 그렇지 않다.

### Stack

* Last In First Out, 가장 마지막에 추가한 값이 가장 처음 나가는 구조로 Vector를 확장해서 만들었다.

* 메소드 호출을 처리하는 구조를 생각하면 이해하기 쉽다.

* 만일 Thread safe 할 필요가 없다면, ArrayDeque를 사용하는 것이 성능상 유리하다.

### LinkedList

* 저장된 값이 자신의 앞, 뒤 값을 알고 있기 때문에 값을 삭제하고 추가하는 과정에서 값의 이동없이 간단하게 연결만 변경하여 처리할 수 있다.

* List 인터페이스와 Queue 인터페이스 모두 구현하고 있기 때문에 동일한 기능을 수행하는 다양한 메소드가 있다. 하지만 내부적으로 동일한 메소드를 호출하기 때문에 해당 메소드를 사용하는 것이 좋다.

    |종류|앞|뒤|
    |---|:---:|:---:|
    |추가|addFirst()|add() 또는 addLast()|
    |조회|getFirst()||
    |삭제|removeFirst()|removeLast()|

## Set

순서는 중요하지 않으며, 중복되는 것을 방지하고 특정 값이 존재하는지의 여부를 확인하기 위해 사용한다. 대표적인 구현 클래스로는 HashSet, TreeSet, LinkedHashSet이 있다.

### HashSet

* 해시 테이블에 저장하며, Set 중 가장 성능이 좋다.

* 객체 생성 시 로드 팩터 값이 설정되는데 적당한 크기를 찾아서 설정해야 한다.

> 로드 팩터란?<br>
(데이터의 개수)/(저장 공간)으로 로드 팩터 값이 커질 수록 저장 공간 내 저장할 수 있는 크기가 커진다. 로드 팩터가 클 수록 조회 성능이 떨어지며, 로드 팩터의 값이 작을 경우 해시 재정리 작업으로 인해 성능에 영향을 미칠 수 있기 때문에 신중하게 설정해야한다.

### TreeSet

* 저장되는 값에 따라서 정렬되며, red-black이라는 트리 타입으로 저장된다.

### LinkedHashSet

* 저장되는 순서에 따라 정렬되며, 해시 테이블에 저장된다.

## Queue

* First In First Out, 가장 먼저 들어온 값이 가장 먼저 나가는 구조로 웹 애플리케이션과 같이 사용자들의 요청을 들어온 순서대로 처리해야 할 때 사용한다.

* 해당 인터페이스를 확장한 Deque는 가장 앞, 뒤에 있는 값을 처리하는데 용이하다.

## Map

키와 값으로 이루어진 자료 구조로, 키는 중복을 허용하지 않는다. 대표적인 구현 클래스로는 HashMap, TreeMap이 있다.

* Hashtable은 Map 인터페이스를 구현했지만 일반적인 다른 구현 클래스들과 다르다.

    * Map은 컬렉션 뷰를 사용하지만, Hashtable은 Enumeration 객체를 통해서 데이터를 처리한다.

    * Hashtable은 엔트리 형식으로 값을 순환하여 처리할 수 없다.

    * Map은 이터레이션을 처리하는 도중에 데이터를 삭제하는 안전한 방법을 제공하지만, Hashtable은 그런 기능을 제공하지 않는다.

### HashMap

* 보통 키는 String이나 Integer와 같이 간단하게 식별할 수 있는 값을 지정한다.

* 직접 정의한 크래스를 키로 사용할 때에는 hashCode() 메소드와 equals() 메소드를 잘 구현해야한다.

### TreeMap

* SortedMap 인터페이스를 구현했으며, 키를 정렬하면서 저장한다.

* 가장 앞, 뒤의 키 그리고 특정 키의 앞, 뒤의 키를 알 수 있는 메소드를 제공한다.