# 영속성 컨텍스트

**엔티티를 영구 저장하는 환경**

* 애플리케이션과 DB 사이에 위치하며, EntityManager를 통해 접근할 수 있다.
* EntityManager의 persist() 메서드는 DB가 아닌 영속성 컨텍스트에 엔티티를 저장한다.

## 엔티티의 생명주기

![Alt text](<이미지/엔티티 생명주기.png>)

#### 비영속
* 영속성 컨텍스트가 관리하지 않는 상태
* 영속성 컨텍스트와 아무런 관계가 없다.
#### 영속
* 영속성 컨텍스트에 의해 관리되는 상태
* 영속성 컨텍스트가 제공하는 기능을 사용할 수 있다.

#### 준영속

* 영속성 컨텍스트에 저장되었다가 분리된 상태
* 영속성 컨텍스트가 관리하지 않기 때문에 변경 감지 등을 사용할 수 없다.

|메서드|적용 범위|
|---|---|
|detach|특정 엔티티만 준영속 상태로 전환|
|clear|영속성 컨텍스트를 완전히 초기화|
|close|영속성 컨텍스트를 종료|

#### 삭제

* 영속성 컨텍스트에서 삭제된 상태

## 동작 방식

영속성 컨텍스트는 내부적으로 다음과 같은 작업을 수행한다.

### 1차 캐시

영속성 컨텍스트 내부에는 1차 캐시가 존재하며, 엔티티를 영속시키면 먼저 1차 캐시에 저장된다. 1차 캐시는 엔티티의 @Id를 키로, 대상 객체를 값으로 가진다.

![Alt text](<이미지/1차 캐시.png>)

애플리케이션은 DB로 데이터를 전송하기 전에 1차 캐시를 먼저 거친다. 만약 DB에서 조회하려는 데이터가 이미 1차 캐시에 존재한다면, DB까지 접근하지 않고 1차 캐시에서 데이터를 반환하게 되고, 결과적으로 조회 쿼리가 생성되지 않는다. 물론 조회 대상이 없으면 DB에서 조회해야 하며, 이 경우에도 DB에서 응답한 결과를 1차 캐시에 먼저 저장한 후 반환한다.

EntityManager는 보통 DB 트랜잭션 단위로 만들어진다. 때문에 트랜잭션이 끝나면 1차 캐시도 사라지며, 동시에 여러 사용자가 요청하면 1차 캐시도 여러 개 생성된다. 이런 이유로 1차 캐시 기능으로 인한 이점이 크지는 않다. 하지만 동작 방식과 컨셉을 이해함으로써 설계상의 이점을 얻을 수 있다.

*참고: 전체를 대상으로 하는 2차 캐시도 존재한다.

### 동일성 보장

영속성 컨텍스트는 엔티티를 참조값으로 관리한다. 따라서 같은 트랜잭션 안에서 영속 엔티티의 동일성이 보장된다. DB의 REPEATABLE READ 등급의 트랜잭션 격리 수준을 애플리케이션 차원에서 제공하는 것으로 볼 수 있다.

### 트랜잭션을 지원하는 쓰기 지연

앞서 엔티티를 영속시키면 1차 캐시에 저장된다고 했다. 이때, JPA는 영속된 엔티티를 분석해서 쿼리를 생성하고, 해당 쿼리를 쓰기 지연 SQL 저장소라는 곳에 저장한다.

![Alt text](<이미지/쓰기 지연 SQL 저장소.png>)

이를 코드로 표현하면 아래와 같다.

```java
em.persist(memberA);
em.persist(memberB);
// SQL을 생성한 후, 저장한다.

transaction.commit(); // DB 트랜잭션을 커밋하는 순간 저장소의 SQL을 DB에 보낸다.
```

DB 트랜잭션을 커밋, 정확히는 flush 하기 전까지는 저장소에 쿼리들이 쌓이기만 한다. 그리고 flush를 통해 실제 DB로 쿼리들이 전달된다. 이렇게 버퍼 기능을 통해 쿼리 저장소에 쿼리를 모아 뒀다가 DB에 한 번에 보낼 수 있다.

### 변경 감지

JPA는 엔티티를 마치 컬렉션의 요소처럼 다룰 수 있도록 고안되었다. 컬렉션에서 요소를 수정할 때, 수정된 요소를 다시 컬렉션에 명시적으로 저장하지 않는다. 마찬가지로 JPA 역시 명시적으로 다시 저장하지 않아도 자연스럽게 수정하는데, 이를 더티 체킹 혹은 변경 감지라고 한다. 영속성 컨텍스트는 변경 내용을 감지하기 위해 1차 캐시 내부에 스냅샷을 관리한다.

![Alt text](<이미지/변경 감지.png>)

엔티티를 수정하면 다음 과정으로 변경을 감지한다.

1. 엔티티가 영속성 컨텍스트에 최초 입성하는 순간을 스냅샷으로 저장해둔다.

2. DB 트랜잭션 커밋 시, flush 과정이 진행된다.

3. 먼저 1차 캐시에 있는 엔티티와 해당 엔티티의 스냅샷을 비교한다.

4. 비교 결과 변경을 감지하면 쿼리를 생성하고 쓰기 지연 SQL 저장소에 저장한다.

4. 쓰기 지연 SQL 저장소에 있는 모든 쿼리들을 DB 반영한다.(flush)

## 플러시

**영속성 컨텍스트의 변경내용을 데이터베이스에 반영**

플러시는 영속성 컨텍스트를 비우는 것이 아니라 영속성 컨텍스트의 변경내용을 DB에 **동기화**하는 것이다. 단지 쓰기 지연 SQL 저장소에 쌓여있는 쿼리를 DB에 전달할 뿐, 1차 캐시에 영향을 미치지 않는다.

#### 플러시 발생 상황

1. em.flush() - 직접 호출
2. DB 트랜잭션 커밋 - 자동 호출
3. JPQL 쿼리 실행 - 자동 호출<br>
※ JPQL은 DB로 바로 전달되기 때문에 쌓여있는 쿼리들이 DB에 반영되어야 정확한 결과를 얻을 수 있다.

DB 트랜잭션이 커밋되면 자동으로 플러시가 발생한다. JPA는 기본적으로 데이터 정합성과 동시성에 관한 부분을 DB 트랜잭션에 위임하는데, 이 트랜잭션이라는 작업 단위가 중요하다. 결국 트랜잭션 커밋 직전에만 동기화(플러시)하면 되기 때문에 영속성 컨텍스트의 생명 주기를 작업 단위에 맞춰서 설계하면, 대부분의 이슈를 해결할 수 있다.