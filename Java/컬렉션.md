# 컬렉션

**목록성 데이터를 처리하는 자료 구조**

* 여러 데이터를 저장하기 위해 사용한다.
* 자바에서 제공하는 자료 구조는 크게 다음과 같다.

![Alt text](<이미지/자바 자료 구조.png>)

## List

* 컬렉션을 확장한 다른 인터페이스와 달리 **순서가 중요**하다.
* 대표적인 구현 클래스로는 `ArrayList`, `Vector`, `Stack`, `LinkedList`가 있다.

### ArrayList

* 가장 많이 사용되는 구체 클래스
* 저장 공간보다 데이터의 크기가 커지면 내부적으로 크기를 늘인다.
  * 해당 과정이 성능에 영향을 줄 수 있기 때문에 초기 크기를 예측해서 지정해 두는 것이 좋다.

### Vector

* **Vector**는 기능적으로 ArrayList와 거의 동일하다.
* Thread safe 여부에 차이가 있으며, **Vector**는 Thread safe 하지만 **ArrayList**는 그렇지 않다.
  * 모든 메서드에 `synchronized` 키워드를 사용하기 때문에 성능이 좋지 않다.

### Stack

* Last In First Out, 가장 마지막에 추가한 값이 가장 처음 나가는 구조 
  * 메소드 호출을 처리하는 구조와 동일
* **Vector**를 확장
  * Thread safe 할 필요가 없다면, **ArrayDeque**를 사용하는 것이 성능상 유리하다.
  * Thread safe 할 필요가 있더라도 다른 방법을 권장

### LinkedList

* 각 요소가 자신의 앞, 뒤 값을 알고 있다.
  * 요소의 이동 없이 연결만 수정하기 때문에 값을 삭제하고 추가하는 과정이 간단하다.
* **List** 인터페이스와 **Queue** 인터페이스 모두 구현하고 있다.
  * 두 가지 자료구조의 기능을 수행할 수 있다.
  * 같은 기능을 수행하는 메서드는 내부적으로 동일한 메소드를 호출한다.

      |종류|앞|뒤|
      |---|:---:|:---:|
      |추가|addFirst()|add() 또는 addLast()|
      |조회|getFirst()||
      |삭제|removeFirst()|removeLast()|

#### ArrayList vs LinkedList 시간복잡도

| \          |add| get  | remove | contains |
|------------|:---:|:----:|:------:|:--------:|
| ArrayList  |O(1)| O(1) |  O(N)  |   O(N)   |
| LinkedList |O(1)| O(N) |  O(1)  |   O(N)   |
* 단, `LinkedList` 삭제시 특정 요소를 탐색 후 삭제해야 한다면 O(N)

## Set

* 순서가 중요하지 않다.
* 중복을 허용하지 않는다.
* 주로 특정 값의 **존재 여부를 확인하기 위해 사용**한다.
* 대표적인 구현 클래스로는 `HashSet`, `TreeSet`, `LinkedHashSet`이 있다.

### HashSet

* 해시 테이블에 저장하며, **Set** 중 가장 성능이 좋다.
* 객체 생성 시 로드 팩터 값이 설정되는데 적당한 크기를 찾아서 설정해야 한다.

> **로드 팩터**<br>
`(가용 저장 공간)/(총 저장 공간)`으로 값이 커질 수록 현재 저장할 수 있는 크기가 커진다.
> 로드 팩터가 클 수록 조회 성능이 떨어지고, 작을수록 해시 재정리 작업의 빈도가 증가하기 때문에 성능에 영향을 미치지 않도록 신중하게 설정해야한다.

### TreeSet

* **값에 따라 정렬**되어 저장된다.
* `red-black` 트리를 활용한다.

### LinkedHashSet

* 저장되는 **순서에 따라 정렬**되며, 해시 테이블에 저장된다.

## Queue

* First In First Out, 가장 먼저 들어온 값이 가장 먼저 나가는 구조
  * 웹 애플리케이션이 요청을 처리하는 것과 동일한 구조
* `Queue`를 확장한 `Deque`는 가장 앞, 뒤에 있는 값을 처리하는데 용이하다.

## Map

* 키와 값으로 이루어진 자료 구조
  * 키는 중복을 허용하지 않는다.
  * 대표적인 구현 클래스로는 `HashMap`, `TreeMap`이 있다.
* `Hashtable`은 `Map` 인터페이스를 구현했지만 일반적인 다른 구현 클래스들과 다르다.
    * `Map`은 컬렉션 뷰를 사용하지만, `Hashtable`은 Enumeration 객체를 통해서 데이터를 처리한다. 
    * `Hashtable`은 엔트리 형식으로 값을 순환하여 처리할 수 없다.
    * `Map`은 이터레이션을 처리하는 도중에 데이터를 삭제하는 안전한 방법을 제공하지만, `Hashtable`은 그런 기능을 제공하지 않는다.

### HashMap

* 키는 주로 `String`, `Integer`와 같이 간단한 식별자를 사용한다.
* 직접 정의한 크래스를 키로 사용할 경우, hashCode() 메소드와 equals() 메소드를 잘 구현해야한다.
  * equals(): 객체의 동등성을 비교하기 위해
  * hashCode(): 해시 자료구조는 요소의 해시값을 먼저 비교하기 때문에 해시가 다르면 즉시 다른 요소로 간주한다.
* `Map` 인터페이스는 key에 null을 허용하지 않지만, 신기하게도 HashMap은 key에 null을 허용한다.
  * 내부적으로 null을 해시값 0으로 변환한다.
  * **왜 HashMap은 key에 null을 허용하는지 조사해보자.**

### TreeMap

* **SortedMap** 인터페이스를 구현
  * 키를 정렬하면서 저장한다.
* 가장 앞, 뒤의 키 그리고 특정 키의 앞, 뒤의 키를 알 수 있는 메소드를 제공한다.