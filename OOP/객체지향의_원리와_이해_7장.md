# 스프링 삼각형

#### *POJO*

Plain Old Java Object의 약어로 과거 EJB를 사용하던 시절 겪었던 불편함에 반발하여 생긴 용어다. 당시에는 무거운 프레임워크에 종속적으로 개발해야 했지만 Spring의 등장으로 이전과 비교할 수 없을 정도로 편리하게 개발할 수 있게 되었다.

스프링을 처음 마주하면 그 거대함 때문에 막막할 수 있다. 하지만 속에 존재하는 단순함 즉, 스프링의 진정한 의미를 알고나면 왜 **경량급 프레임워크**라고 하는지 이해할 수 있다.

앞서 말한 단순함은 스프링의 3대 프로그래밍 모델이며, 스프링 삼각형이라고도 표현한다.

## IoC/DI

객체를 생성하고 대입하는 모든 곳에 의존성이 생긴다. 이때 의존 관계를 스스로 선택하는지, 아니면 외부에서 주입하는지에 따라 차이가 발생한다.

```java
public class Car {
    private Tire tire = new KoreanTire(); // 스스로 의존 관계를 선택
}

public class Car {
    private Tire tire;

    public Car(Tire tire) { // 외부 주입
        this.tire = tire;
    }
}
```

의존 관계를 스스로 선택하는 것은 그에 대한 결정권이 있다는 의미이다. 반면 외부에서 주입받는 경우는 결정권이 없으며, 주입해주는 대로 사용해야 한다.

이렇게 의존 관계를 스스로 결정하지 않고 외부에 맡기는 것을 DI 즉, 의존 관계 주입이라고 하며 제어의 흐름을 외부에 넘기기 때문에 IoC(제어의 역전)이라고도 한다.

DI는 스프링에서 사용하는 용어이며, IoC는 객체뿐만 아니라 프레임워크 등 다양한 곳에서 사용되는 용어로 스프링 DI는 IoC의 하위 분류이다.

#### 참고! 의존 관계는 집합 관계와 구성 관계로 구분할 수 있다.
|||
|---|---|
|집합 관계|부분이 전체와 다른 생명 주기를 가질 수 있다.|
|구성 관계|부분은 전체와 같은 생명 주기를 갖는다.|

### 설정자 주입

설정자를 사용해서 의존 관계를 주입할 수 도 있다.

```java
public class Car {
    Tire tire;

    public void setTire(Tire tire) {
        this.tire = tire;
    }
}
```

생성자로 주입하면 생성과 동시에 주입하는 반면, 설정자로 주입하면 이미 생성한 후 주입한다. 따라서 생성자 주입은 생성 시점에만 주입할 수 있지만 설정자 주입은 자유자재로 변경할 수 있다.

다만 불변 객체의 장점으로 생성자 주입을 선호하는 추세이다. 현실세계의 경우 교체가 빈번할 수 있지만 프로그래밍에서는 계속 사용하는 경우가 대부분이기 때문이다.

다르게 말하면 오래 사용한다기 보다 대부분의 객체들이 생성되고 곧바로 사라지기 때문에 굳이 변경가능성을 열어둘 필요가 없다고 할 수 있다.

### @Autowired

스프링은 의존 관계의 주입을 더 간편하게 지원한다.

```java
@Component // 스프링 컨테이너에 등록
public class Car {
    private final Tire tire;

    @Autowired
    public Car(Tire tire) {
        this.tire = tire;
    }
}

@Component
public class KoreaTire implements Tire {
    public String getBrand() {
        return "한국 타이어";
    }
}
```
@Component 어노테이션으로 스프링 컨테이너에 등록하면, 등록 시점에 자동으로 의존 관계를 주입해준다. 따라서 실제 사용할 때는 이미 의존 관계 주입이 완료된 객체를 꺼내 사용하기만 하면 된다.

여기서 실제 타이어들을 Tire로 추상화한 부분도 주목해야한다.

Tire의 추상화와 스프링 DI의 합작으로 완전하게 OCP와 DIP를 준수하게 되었고, 이후부터 다른 코드는 손 댈 필요 없이 어노테이션이나 설정 정보만 수정하면 된다.


이렇게 변경 사항이 생겨도 역할들의 협력 관계를 그대로 사용할 수 있는 것이 스프링이 주는 가치의 핵심이다.

### 자동 빈 등록 vs 수동 빈 등록

스프링 빈은 역할에 따라 두 가지로 구분할 수 있다.

#### 업무 로직 빈
웹을 지원하는 **컨트롤러**, 핵심 비즈니스 로직이 있는 **서비스**, 데이터 계층의 로직을 처리하는 **리포지토리** 등으로, 보통 비즈니스 요구사항을 개발할 때 추가되거나 변경된다.

#### 기술 지원 빈
기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용되며, 데이터베이스 연결이나 로그 처리처럼 업무 로직을 지원하기 위한 공통 기술들이다.

업무 로직은 수가 매우 많고 어느정도 유사한 패턴이 있으며, 보통 문제가 발생해도 어떤 곳에서 문제가 발생했는지 파악하기 쉽다. 이런 경우 편리한 자동 빈 등록을 적극 사용하는 것이 좋다. 

반면, 기술 지원 로직은 업무 로직과 비교해서 그 수가 매우 적고 보통 애플리케이션 전반에 걸쳐서 광범위하게 영향을 미친다. 또, 적용이 잘 되고 있는지 조차 파악하기 어려운 경우가 많기 때문에 수동 빈 등록을 사용해서 명확하게 드러내는 것이 좋다.

# AOP

Aspect Oriented Programming으로 OOP만으로는 횡단 관심사를 깔끔하게 처리하기 힘들어 이를 보조하기 위해 개발되었다. AOP는 핵심 기능과 부가 기능을 분리해 중복을 제거하고 SRP을 준수하도록 한다.

> **횡단 관심사**<br>
비즈니스에 핵심적인 부분이 아닌 애플리케이션 전반에 공통으로 적용되는 부분.<br>
주로 부가 기능들을 횡단 관심사라 한다.

스프링 DI가 의존성의 주입이라면 AOP는 로직을 주입하는 것이라 표현할 수 있다.

![Alt text](<이미지/Aspect 구성.png>)

### JoinPoint

AOP가 적용되는 지점으로 다음 두 가지 개념으로 사용된다.

* 광의의 JoinPoint: 스프링 프레임워크가 관리하는 빈의 모든 메서드

* 협의의 JoinPoint: 호출된 객체의 메서드

적용 지점의 메서드 뿐만 아니라 파라미터 정보, 인스턴스의 정보 등을 제공한다.

### Pointcut

AOP를 적용 시키려는 곳을 지정한다. 표현식은 다음과 같다.

*[접근제한자]**리턴타입**[패키지&클래스]**메서드이름(파라미터)**[throws 예외]*

리턴 타입, 메서드 이름, 파라미터는 필수 요소다.

### Advice

적용시키려는 부가 기능 그리고 적용 시점을 정의한다.

### Aspect

여러개의 Pointcut과 Advice로 구성된다. 부가 기능과 해당 부가 기능을 어디에, 언제 적용할지 정의한다.

### Advisor

하나의 Pointcut과 하나의 Advice로 구성된다. 스프링 AOP에서만 사용하는 용어로 Aspect를 사용하는 것을 권장한다.

## AspectJ

AOP의 대표적인 구현으로 AspectJ 프레임워크가 있으며, 스프링은 AspectJ의 문법을 차용하고 프록시 방식의 AOP를 적용한다. 즉, 스프링 AOP는 AspectJ를 직접 사용하는 것이 아니라 AspectJ가 제공하는 기능 중 실무에 자주 사용되는 일부 기능만 차용해서 지원한다.

AOP의 적용 방식은 다음 세 가지가 있다.

1. 컴파일 시점: 부가 기능 코드가 핵심 기능 코드 주변에 실제로 붙는다. 특별한 컴파일러가 필요하고 복잡해서 잘 사용하지 않는다.(AspectJ필요)

2. 클래스 로딩 시점: 클래스 로더에서 .class 파일을 조작한 다음 JVM에 올린다. 자바를 실행할 때 특별한 옵션을 통해 클래스 로더 조작기를 지정해야 하는데 이 방식이 번거롭고 운영하기 어려워서 잘 사용하지 않는다.(AspectJ필요)

3. 런타임 시점: 자바가 실행되고 나서 조작하기 때문에 자바 언어가 제공하는 범위 안에서 부가 기능을 적용해야한다. 생성자, static, 필드에는 접근하지 못하고 메서드 실행 지점에만 적용가능하다.

스프링 AOP는 런타임 시점에 프록시를 사용해서 부가기능을 적용한다.

## 동적 프록시

실행 로직을 지정하면 직접 프록시 클래스를 만들지 않아도 런타임 시점에 프록시 객체를 동적으로 생성한다.

### JDK 동적 프록시

자바가 제공하는 기술로 인터페이스를 기반으로 프록시를 생성하며, 적용할 로직은 InvocationHandler 인터페이스를 구현해서 작성하면 된다. 인터페이스가 반드시 필요하다는 단점이 있다.

### CGLIB(Code Generator Library)

바이트코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리이다. 인터페이스 없이 구체 클래스를 상속해서 동적 프록시를 생성한다.

상속을 기반으로 프록시를 생성하기 때문에 기본 생성자가 필요하며, 클래스와 메서드에 final 키워드를 사용할 수 없는 제약이 생긴다.

스프링은 위의 단점을 보완하고 두 가지 기술을 적절하게 사용할 수 있도록 ProxyFactory를 제공한다.

# PSA

일관성 있는 서비스 추상화로 Adapter Pattern을 적용해서 같은 일을 하는 서로 다른 기술들을 공통의 인터페이스로 제어할 수 있게 한다. 스프링 프레임워크는 서비스 추상화를 위해 다양한 Adapter를 제공한다.

하나의 예로 @Repository는 데이터 접근 계층을 나타내는 어노테이션으로 데이터 접근 계층에 대한 예외를 추상화하여 일관된 예외 계층을 제공해준다. 추상화된 예외는 특정 기술에 종속되지 않기 때문에 JDBC, JPA 등 어떤 기술을 사용하더라도 일관성 있게 예외를 처리할 수 있다.