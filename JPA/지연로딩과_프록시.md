# 지연로딩

**엔티티 조회 시, 사용하지 않는 참조를 지연처리하는 방법**

* 프록시와 지연로딩을 사용해서 불필요한 쿼리발생을 방지할 수 있다.
* 모든 관계는 지연로딩으로 설정해야 한다고 생각하자.
    * @xxxToOne은 기본값이 즉시로딩이기 때문에 지연로딩으로 지정해야 한다.

## 프록시

* EntityManager의 getReference() 메서드를 통해 프록시가 생성된다.
* 참조되는 엔티티를 사용하기 전까지, 실제 엔티티 대신 프록시가 위치한다.
    * 직접 사용할 때, 프록시가 영속성 컨텍스트에 타겟 생성을 요청하고 초기화된다.
    * 처음 한 번만 초기화되고, 이후 생성된 타켓을 사용한다.
    * 이때, **프록시가 실제 타겟으로 바뀌는 것이 아니다!**
* 영속성 컨텍스트에 이미 엔티티가 존재하면, 프록시가 사용되지 않는다.
    * **동일한 트랜잭션 안에서 객체의 동일성을 보장**해주기 때문!
    * 영속성 컨텍스트에 프록시가 먼저 등록되었다면, em.find() 메서드를 호출해도 실제 객체 대신 초기화된 프록시를 반환한다.
* 초기화되지 않은 프록시가 준영속 상태가 되면 초기화할 수 없다.
    * 영속성 컨텍스트가 관리하지 않기 때문!
    * 준영속 뿐만 아니라 트랜잭션, 영속성 컨텍스트가 종료되어도 마찬가지다.

## 즉시로딩을 사용하면 안되는 이유

* 전혀 예상하지 못한 쿼리가 발생한다.
* JPQL에서 N+1 문제를 발생시킨다.
    * JPQL은 SQL로 그대로 번역되기 때문에 즉시로딩을 사용해도 한 번에 가져오지 못하고, 이미 조회된 결과에 뒤늦게 할당한다.
    * 지연로딩과 fetch join을 사용해서 N+1 문제를 해결하자.