# 클래스 파일(*.class) 포맷
JVM의 동작방식을 이해하기 위해 클래스 파일 포맷에 대해 간단히 알아보자.

![Alt text](<이미지\자바 애플리케이션의 구동 원리.png>)

우리가 작성한 소스파일은 컴파일을 거쳐 클래스 파일이 된다. 클래스 파일의 큰 골격은 다음과 같다.

```
ClassFile {  
u4 magic;  
u2 minor_version;  
u2 major_version;  
u2 constant_pool_count;  
cp_info constant_pool[constant_pool_count-1];  
u2 access_flags;  
u2 this_class;  
u2 super_class;  
u2 interfaces_count;  
u2 interfaces[interfaces_count];  
u2 fields_count;  
field_info fields[fields_count];  
u2 methods_count;  
method_info methods[methods_count];  
u2 attributes_count;  
attribute_info attributes[attributes_count];  
}
```

* magic: 클래스 파일의 첫 4바이트는 magic number이다. 자바 클래스 파일을 구별하기 위해 미리 지정해 둔 값을 의미하며, 항상 0xCAFEBABE이다.

* minor_version, major_version: 클래스 버전을 나타내며 JDK 버전에 따라 달라진다.

* constant_pool_count, constant_pool[]: 클래스 파일의 상수 풀 정보를 기술한다. **JVM은 클래스 파일을 로드하면서 이 constant_pool 정보를 메소드 영역의 런타임 상수 풀에 넣는다.**

* access_flags: 주로 클래스의 modifier 정보, 즉 public, final, abstract나 인터페이스 여부를 나타내는 플래그이다.

* this_class, super_class: this, super에 해당하는 클래스들에 대한 constant_pool 내의 인덱스이다.

* interfaces_count, interfaces[]: 클래스가 구현한 인터페이스의 개수와 각 인터페이스에 대한 constant_pool 내의 인덱스이다.

* fields_count, fields[]: 클래스의 필드 개수와 필드 정보이다. 필드 정보에는 필드 이름, 타입 정보, modifier, constant_pool에서의 인덱스 등이 포함된다.

* methods_count, methods[]: 클래스의 메소드 개수와 메소드 정보이다. 메소드 정보는 메소드 이름, 파라미터 타입과 개수, 반환 타입, modifier, constant_pool에서의 인덱스와 함께 메소드 자체의 실행 코드, 예외 정보 등의 내용도 포함한다.

* attributes_count, attributes[]: attribute_info 구조체는 다양한 속성을 갖고 있다.

# JVM 구조
자바 애플리케이션은 JVM 내에서 다음 그림과 같은 과정을 통해 수행된다.

![Alt text](<이미지\JVM 구조.png>)

클래스 로더가 컴파일된 자바 바이트코드를 런타임 데이터 영역에 로드하고, 실행 엔진이 자바 바이트코드를 실행한다.

# 클래스 로더(Class Loader)
클래스 로더는 클래스 파일을 한번에 메모리에 올리지 않고 애플리케이션에서 필요한 경우 동적으로 로드하며, 로드된 클래스 파일들을 엮어서 JVM의 메모리 영역인 런타임 데이터 영역에 배치한다.

클래스 파일은 다음 3단계로 로드된다.

![Alt text](<이미지\클래스 로드 과정.png>)

* Loading : 클래스 파일을 가져와서 JVM의 메모리에 로드한다.
* Linking : 클래스 파일을 사용하기 위해 검증하는 과정이다.
    * Verifying : 읽어들인 클래스가 JVM 명세에 명시된 대로 구성되어 있는지 검사한다.
    * preparing : 클래스가 필요로 하는 메모리를 할당한다.
    * Resolving : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.
* Initialization : 클래스 변수들을 적절한 값으로 초기화한다.

# 실행 엔진(Execution Engine)
클래스 로더를 통해 JVM 내의 런타임 데이터 영역에 배치된 바이트코드는 실행 엔진에 의해 기계가 실행할 수 있는 형태로 변경된다. 그 방식은 다음 두 가지가 있다.

## 인터프리터
바이트코드는 기본적으로 인터프리터 방식으로 동작하며 명령어를 하나씩 해석하고 실행한다. 때문에 바이트코드 하나하나의 해석은 빠른 대신 인터프리팅 결과의 실행은 느리다는 단점을 가지고 있다.

## JIT(Just-In-Time) 컴파일러
인터프리터의 단점을 보완하기 위해 도입된 것이 JIT 컴파일러이다.<br>
인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고, 이후에는 해당 메소드를 더 이상 인터프리팅하지 않고 네이티브 코드로 직접 실행하는 방식이다.

바이트코드를 네이티브 코드로 변환하는 비용이 크기 때문에 JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메소드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘을 때에만 컴파일을 수행한다.

# 런타임 데이터 영역(Runtime Data Areas)
JVM이 운영체제 위에서 실행되면서 할당받는 메모리 영역으로 6개의 영역으로 나눌 수 있다.

![Alt text](<이미지\런타임 데이터 영역.png>)

## PC 레지스터
* PC(Program Counter) 레지스터는 각 쓰레드마다 하나씩 존재하며 쓰레드가 시작될 때 생성된다.
*  PC 레지스터는 현재 수행 중인 JVM 명령의 주소를 갖는다.

## JVM 스택
* JVM 스택은 각 쓰레드마다 하나씩 존재하며 쓰레드가 시작될 때 생성된다.
* 스택 프레임(Stack Frame)이라는 구조체를 저장하는 스택으로, JVM은 오직 JVM 스택에 스택 프레임을 추가하고(push) 제거하는(pop) 동작만 수행한다.

### 스택 프레임
* JVM 내에서 메소드가 수행될 때마다 하나의 스택 프레임이 생성되어 해당 쓰레드의 JVM 스택에 추가되고 메소드가 종료되면 스택 프레임이 제거된다.
* 각 스택 프레임은 지역 변수 배열(Local Variable Array), 피연산자 스택(Operand Stack), 현재 실행 중인 메소드가 속한 클래스의 런타임 상수 풀에 대한 레퍼런스를 갖는다.

### 지역 변수 배열
* 0번지부터 시작하는 인덱스를 가진 배열이다.
* 0번지는 메소드가 속한 클래스 인스턴스의 this 레퍼런스이고, 1번지부터는 메소드에 전달된 파라미터들이 저장되며, 메소드 파라미터 이후에는 메소드의 지역 변수들이 저장된다.

### 피연산자 스택
* 메소드의 실제 작업 공간이다.
* 각 메소드는 피연산자 스택과 지역 변수 배열 사이에서 데이터를 교환하고, 다른 메소드 호출 결과를 추가하거나(push) 꺼낸다(pop).

## 네이티브 메소드 스택
* 자바 외의 언어로 작성된 네이티브 코드를 위한 스택이다.
* JNI(Java Native Interface)를 통해 호출하는 C/C++ 등의 코드를 수행하기 위한 스택으로, 언어에 맞게 C 스택이나 C++ 스택이 생성된다.

>네이티브 코드: CPU와 운영체제가 직접 실행할 수 있는 코드

## 메소드 영역
* 메소드 영역은 모든 쓰레드가 공유하는 영역으로 JVM이 시작될 때 생성된다.
* JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메소드 정보, Static 변수, 메소드의 바이트코드 등을 보관한다.

![Alt text](<이미지\메소드 영역.png>)

## 런타임 상수 풀
* 클래스 파일 포맷에서 constant_pool 테이블에 해당하는 영역이다. 메소드 영역에 포함되는 영역이긴 하지만, JVM 동작에서 가장 핵심적인 역할을 수행하는 곳이기 때문에 JVM 명세에서도 따로 중요하게 기술한다.
* 각 클래스와 인터페이스의 상수뿐만 아니라, 메소드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다. 즉, 어떤 메소드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메소드나 필드의 실제 메모리상 주소를 찾아서 참조한다.

## 힙
* 인스턴스 또는 객체를 저장하는 공간으로 가비지 컬렉션 대상이다.
* JVM 성능 등의 이슈에서 가장 많이 언급되는 공간이며, 힙 구성 방식이나 가비지 컬렉션 방법 등은 JVM 벤더의 재량이다.