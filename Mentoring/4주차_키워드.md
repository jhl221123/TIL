# 병렬 프로그래밍

서로 독립된 작업들을 여러 개의 프로세서로 동시에 처리하는 프로그래밍 기법을 말하며, 물리적으로는 현재 장비의 논리프로세서 수 만큼 병렬처리 할 수 있다. 대량의 데이터를 빠르게 처리해야 하는 경우 사용할 수 있다.

## 자바의 병렬 프로그래밍

자바는 병렬 프로그래밍을 지원하기 위해 Thread 클래스를 제공한다. Thread 클래스를 구현해 생성된 쓰레드는 JVM을 통해 애플리케이션(프로세스)에서 동시에 실행된다.

하나의 프로세스 안에서 실행되는 각기의 실행 흐름을 쓰레드라고 하며, 프로세스에 비해 메모리를 적게 차지하기 때문에 '경량급 프로세스'라고도 한다. 

### ThreadPool

ThreadPool은 쓰레드 자원을 관리하며, 많은 수의 비동기 작업을 실행할 때 향상된 성능을 제공한다.

Executors 클래스의 newWorkStealingPool(), newFixedThreadPool() 메서드 등을 통해 ThreadPool을 생성할 수 있다. WorkStealingPool은 내부적으로 ForkJoinPool을 사용하는데 병렬 스트림도 내부적으로 ForkJoinPool을 사용하기 때문에 병렬 프로그래밍이 가능하다.

# 비동기 프로그래밍

주 실행 흐름에서 발생한 작업의 종료 여부와 관계 없이 다음 작업을 실행할 수 있도록 하는 프로그래밍 기법을 말한다. 

동기와 비동기의 차이는 아래와 같다.

|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||
|---|---|
|동기|작업 실행 시, 해당 작업이 완료될 때까지 다른 작업을 수행하지 않는다.<br>작업이 완료된 후, 다음 작업을 수행한다.|
|비동기|작업이 실행되는 동안 다른 작업을 수행할 수 있다.<br>비동기 처리된 작업의 결과는 작업 완료 후 반환된다.|

## JAVA의 비동기 프로그래밍

자바는 비동기 프로그래밍을 지원하기 위해 Future 인터페이스를 제공한다.

### Future

비동기적인 요청을 처리하고 결과를 나타내기 위해 사용한다. 계산이 완료되었는지 확인하는, 계산이 완료될 때까지 기다리는, 계산 결과를 가져오는 메서드들을 제공한다.

계산이 완료된 경우에만 get() 메서드를 사용하여 결과를 검색할 수 있으며, 필요한 경우 준비가 될 때까지 기다린다. 취소 메서드로 작업을 취소할 수 있으며, 이미 완료되었다면 계산을 취소할 수 없다.

```java
interface ArchiveSearcher { String search(String target); }
 class App {
   ExecutorService executor = ...;
   ArchiveSearcher searcher = ...;
   void showSearch(String target) throws InterruptedException {
     Callable<String> task = () -> searcher.search(target);
     Future<String> future = executor.submit(task);
     displayOtherThings(); // 비동기 작업 요청 후 다른 작업 수행
     try {
       displayText(future.get()); // 작업 결과 반환
     } catch (ExecutionException ex) { cleanup(); return; }
   }
 }
```

FutureTask 클래스는 RunnableFuture(Future와 Runnable을 구현)의 구현 클래스로 다음과 같이 사용할 수 있다.

```java
FutureTask<String> future = new FutureTask<>(task);
executor.execute(future);
```

#### 하지만!
Future는 외부에서 완료시킬 수 없고, 여러 Future를 조합할 수 없다는 단점이 있다. 만약 두 가지 이상의 비동기 작업에 의존성이 존재한다면 Future만으로 처리하기 힘들어진다.

또, 해당 작업에서 발생한 예외를 바로 처리할 수 없어 외부에서 try-catch를 통해 처리해야한다.

Future와 CompletionStage를 구현한 CompletableFuture 클래스는 이런 단점을 보완한다.

### CompletionStage

비동기 연산을 수행할 수 있는 스테이지로, 다른 CompletionStage가 완료될 때 동작을 수행한다. 계산이 종료되면 스테이지가 완료되거나 다른 스테이지를 트리거할 수 있다.

### CompletableFuture

CompletableFuture는 Future의 단점을 보완하며, 다음의 작업을 수행할 수 있다.

#### 비동기 작업

Future와 마찬가지로 비동기 작업을 수행한다.

|||
|---|---|
|runAsync()|주어진 액션을 실행한 후 값을 반환하지 않는다. 매개 변수로 Executor를 전달하지 않으면 ForkJoinPool.commonPool()을 사용해서 수행된다.|
|supplyAsync()|runAsync()와 같은 역할을 하지만 반환값이 있다.|

#### 작업 콜백

이전 작업과 연계해서 다음 작업을 수행할 수 있다.

|||
|---|---|
|thenApply|이전 작업의 결과를 받아 Function으로 처리한 후, 다른 값으로 반환한다.|
|thenAccept|이전 작업의 결과를 받아 Consumer로 처리하고 값을 반환하지 않는다.|
|thenRun|이전 작업의 결과를 받지 않고 Runnable을 사용해 다음 작업을 처리한다.|

#### 작업 조합

각 작업을 조합해서 수행할 수 있다.

|||
|---|---|
|thenCompose|이전 작업과 이어서 수행하는 방식으로, 이전 작업의 결과를 받아서 사용할 수 있다.|
|thenCombine|이전 작업과 별개로 각 작업이 독립적으로 실행되며, 두 작업이 모두 정상적으로 완료되면 새로운 결과를 반환한다.|

#### 예외 처리

작업 수행중 발생한 예외를 처리할 수 있다.

|||
|---|---|
|exceptionally|이전 작업에서 발생한 예외를 처리할 수 있다.|

# 인터페이스 vs 추상클래스

둘 다 공통적으로 추상 메서드와 이미 구현된 메서드를 가질 수 있지만 인터페이스는 public 정적 상수만 가질 수 있기 때문에 상태를 가지지 않는다.

따라서 인터페이스는 함수형 프로그래밍처럼 일관된 작업을 해야하는 경우 유리하며, 추상클래스는 상위 분류로써 공통 상태를 표현해야 하는 경우 사용할 수 있다.

# 예외

비정상적인 시스템 상황으로 인해 발생하는 **에러**와 다르게, 작성한 애플리케이션 코드에 문제가 있을 경우 발생하는 것을 예외라고 한다. 예외는 체크 예외와 언체크 예외로 구분된다.

#### 체크 예외

RuntimeException 하위 클래스를 제외한 예외 클래스들로 바로 예외처리를 해야한다. try-catch 구문을 사용하거나 메소드 밖으로 던져서 처리할 수 있으며, 처리하지 않으면 컴파일 에러가 발생한다.

#### 언체크 예외

RuntimeException 하위 클래스들로 반드시 예외처리를 하지 않아도 된다. 따라서 throws를 생략할 수 있다.

---

체크 예외는 컴파일 에러를 통해 실수를 방지할 수 있는 장점이 있지만, 매번 예외 처리를 해야한다는 단점이 있다. 반면 언체크 예외는 컴파일러가 체크하지 않지만 매번 예외처리를 하지 않아도 된다. 그럼 어떤 예외를 사용해야 할까?

#### 기본적으로 언체크 예외를 사용하고 비즈니스적으로 정말 중요한 부분에만 체크 예외를 사용하자.

체크 예외는 바로 예외를 처리해야 한다고 했는데, 일반적으로 예외가 발생하면 그 자리에서 바로 해결할 수 있는 경우는 극히 드물다. 때문에 메서드 밖으로 던지게 되고, 웹 애플리케이션의 경우 최종적으로 WAS까지 올라와 적절한 오류 페이지를 보여주게 된다.

만약 발생한 예외가 DB관련 예외라면 어떨까?

DB에서 발생한 예외를 서비스, 컨트롤러 계층에서 불필요하게 의존해야 하는 문제가 생긴다.

이런 문제를 방지하기 위해 언체크 예외를 사용하며, 위와 같은 상황에서는 기존 예외를 포함하는 언체크 예외를 생성함으로써 문제를 해결할 수 있다.

### @Transactional

스프링이 제공하는 기능으로 예외 종류에 따라 롤백 여부에 차이가 있다. 기본적으로 해당 트랜잭션 내에서 언체크 예외 발생 시 롤백하지만 설정을 통해 변경할 수 있다.

# 내부클래스(InnerClass) 사용 시 주의 사항

내부 클래스의 인스턴스 생성 시 외부 클래스의 인스턴스도 같이 생성되며, 내부 클래스의 인스턴스는 외부 클래스의 인스턴스를 참조한다. 만약 외부 클래스의 자원을 사용하지 않는다면 불필요한 자원으로 메모리 낭비가 발생한다.

또, 내부 클래스의 인스턴스가 외부 클래스의 인스턴스를 참조하고 있기 때문에 해당 인스턴스를 사용하지 않음에도 GC 대상이 되지 않는다. 따라서 static nested class를 사용해서 외부 클래스의 인스턴스 생성 없이 내부 클래스의 인스턴스를 생성할 수 있도록 해야한다.

여기서 static 키워드는 외부 인스턴스 참조 없이 내부 인스턴스 생성이 가능하다는 의미로 인스턴스의 수와는 무관하다.

# 간단하게 알아볼 내용

#### Jenkins IAC
'Infrastructure as Code'의 약어로 Jenkins를 사용해서 인프라스트럭처를 코드화 하는 것이다. 자동화된 CI/CD 파이프라인을 만드는데 유용하며, 프로젝트를 공유하고 효율적으로 관리할 수 있도록 한다.

#### weak generational hypothesis

대부분의 객체들은 생성된 후, 곧바로 GC대상이 된다는 가설이다. 이 가설을 기반으로 힙 영역을 Young Generation과 Old Generation으로 구분해서 GC를 수행한다. 

#### String 클래스의 hashcode

```java
public int hashCode() {
        int h = hash; // Default to 0
        if (h == 0 && value.length > 0) {
            char val[] = value;

            for (int i = 0; i < value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
}
```

1. 해당 문자열을 문자 배열로 만든다.

2. 해시에 31을 곱한 값에 각 문자의 아스키코드 값을 더한 후, 해시에 대입한다.

3. 모든 문자를 대상으로 반복한다.

31을 곱하는 이유는 다음과 같다.

* 해시 충돌의 최소화: 소수를 사용하면 해시함수의 범위가 넓어지고, 각 문자가 해시 코드에 미치는 영향이 더 커져서 충돌이 적게 발생한다.

* 비트 연산의 최적화: 31은 2<sup>5</sup>에서 1을 뺀 값으로, 이진수 11111로 표현할 수 있다. 이런 특징은 비트 연산을 효과적으로 하도록 돕는다.

#### CSR vs SSR

CSR은 클라이언트 사이드 렌더링으로 웹 애플리케이션의 렌더링을 웹 브라우저에서 진행하는 방식이다. 필요한 데이터만 가져오기 때문에 초기 로딩 속도가 빠른 장점이 있다.

SSR은 서버 사이드 렌더링으로 서버측에서 렌더링하는 방식이다. 완성된 형태로 클라이언트에게 전달하기 때문에 초기 로딩 속도가 느릴 수 있다.