# 객체 지향이란?

**기계 중심의 프로그래밍 방식에서 벗어나 인간이 이해하기 쉬운, 인간 지향적인 프로그래밍 방식**

* 기계 종속적인 개발에서 벗어나 현실 세계처럼 프로그래밍하려는 고민 속에서 객체 지향의 개념이 탄생했다.
* 절처적/구조적 프로그래밍까지는 인간이 기계를 이해하려는 방식이었다.
  * 상태와 행위를 분리된 형태로 관리
* 객체 지향에서는 객체 단위로 **상태와 행위를 함께 관리**하기 때문에 더 직관적이고 인간적이다.

# 객체 지향의 4대 특성

먼저 클래스와 객체에 대한 오해부터 바로 잡아야한다.

흔히 클래스는 객체의 설계도라고 표현하는데 이는 일부만 맞는 말이다.

다음을 보면 클래스는 단지 객체를 만들기 위한 틀이 아니라 객체의 **분류**에 대한 개념이라는 것을 알 수 있다.

```java
붕어빵틀 붕어빵 = new 붕어빵틀(); // ?

동물 호랑이 = new 동물(); // !
```

객체를 유일무이한 사물이라고 정의한다면 클래스는 같은 속성과 기능을 가진 객체를 총칭하는 개념 즉, 분류 또는 집합이라고 정의할 수 있다.

따라서 객체를 특성에 따라 분류하면 클래스가 된다고도 할 수 있다.

## 추상화

구체적인 것을 분해해서 관심 있는 특성만 가지고 재조합하는 것으로 객체 지향의 추상화는 **모델링**이라고 할 수 있다. 모델은 목적에 맞게 관심 있는 특성만을 추출해서 표현하는 것으로 추상화를 통해 실제 사물을 단순하게 묘사한 것이다.

사람을 예로 들면 다음과 같은 특성들이 있다.

![Alt text](<이미지/사람의 특성.png>)

### Context

클래스의 모든 속성을 애플리케이션에 사용할 필요는 없다. 병원에서의 사람 역할과 은행에서의 사람 역할이 다른 것 처럼 애플리케이션 내에서 해당 클래스의 역할에 따라 사용할 속성을 선택하면 된다. 이때 선택 기준을 Context(애플리케이션 경계)라고 하며, 애플리케이션 경계 내에서 필요한 속성들만 사용하면 된다.

정리하면 다음과 같다.

* OOP의 추상화는 모델링이다.

* 클래스 설계에서 추상화가 사용된다.

* 클래스 설계를 위해서 애플리케이션 경계를 정해야 한다.

* 객체 지향에서 추상화의 결과는 클래스다.

## 상속

자바에서 상속은 무엇을 물려받는 개념이 아니라 확장하는 것이다.

만약 상속이 물려받는 것이었다면 상위클래스의 특성을 가지고 있는 하나의 하위클래스만 메모리에 존재하겠지만 실제로는 하위클래스와 함께 상위클래스도 별도로 생성된다.

```java
Tiger hodol = new Tiger();
```

![Alt text](<이미지/상속 메모리 구조.png>)

따라서 상속이라는 단어보다 재사용과 확장으로 이해하는 것이 적절하다.

상속을 통해 하위 클래스에서 상위 클래스의 메서드를 다시 작성하지 않아도 되지만 오직 재사용하기 위한 목적이라면 상속이 아니라 조합을 사용하는 것이 좋다.

---

클래스는 분류라고 했다. 상속을 통해 상위 클래스, 하위 클래스로 나누었다면 상위 분류와 하위 분류라고 표현할 수 있다. 하위 분류는 상위 분류에 포함될 수 있기 때문에 다음과 같이 나타낼 수 있다.

    상위 클래스 = 하위 클래스

당연하게도 반대는 성립하지 않는다.

이를 메모리에서 살펴보면 다음과 같다.

```java
Animal hodol = new Tiger();
```

![Alt text](<이미지/상속 메모리 구조2.png>)

위와 같이 하위 객체를 생성했지만 상위 객체를 참조하기 때문에 하위 객체에는 접근할 수 없다. 하지만 하위 클래스에서 재정의한 메소드는 적용된다.

하위 클래스가 상위 클래스에 포함되는 특성으로 인해 객체를 더욱 효과적으로 분류할 수 있으며, 그 만큼 클래스를 효과적으로 사용할 수 있다.

### 상속은 is a 관계가 아니라 is a kind of 관계다.

앞서 설명한 것 처럼 하위 클래스는 하나의 상위 클래스가 아니라, 상위 클래스의 한 종류라고 표현하는 것이 적절하다.

### 다중 상속

자바는 다중 상속을 지원하지 않는다. 아래의 예시를 살펴보자.

![Alt text](<이미지/다중 상속의 문제점.png>)

인어의 행위를 결정할 때, 사람과 물고기 중 어떤 클래스를 사용해야 할지 지정해야 하는데 이런 문제를 다중 상속의 다이아몬드 문제라고 한다.

자바는 이 문제를 해결하기 위해 다중 상속을 지원하는 대신 인터페이스를 도입했다.

인터페이스는 is able to 관계로 행위에 대해 정의하고 이를 강제로 구현하도록 하기 때문에 상속을 사용하지 않고도 행위를 확장하는 효과를 가질 수 있다.

정리하면 다음과 같다.

* 객체 지향의 상속은 상위 클래스의 특성을 재사용하고 **확장**하는 것이다.

* 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.

## 다형성

사용 편의성이라 표현할 수 있으며 상위 클래스와 하위 클래스, 인터페이스와 구현 클래스 사이의 다형성도 있지만 가장 기본은 오버라이딩과 오버로딩이다. 다형성을 지원하지 않는 언어는 같은 이름의 함수를 추가로 생성할 수 없다.

오버라이딩과 오버로딩을 메모리 구조로 살펴보자.

![Alt text](<이미지/다형성 메모리 구조1.png>)

오버라이딩은 재정의를 통해 상위 객체의 메소드를 덮어버린다. 반면 오버로딩은 하위 객체에만 존재한다.

따라서 다음과 같아 하위 객체를 생성했지만 상위 클래스 타입일 경우, 하위 객체에서 오버로딩한 메서드는 접근할 수 없다.

![Alt text](<이미지/다형성 메모리 구조2.png>)

정리하면 다음과 같다.

* 오버라이딩은 메서드 재정의

* 오버로딩은 메서드 중복 정의

## 캡슐화

객체가 자신의 역할에 맞게 사용될 수 있도록 정보를 은닉하거나 원하는 곳만 공개할 수 있도록 하는 것이다. 자바에서는 접근 제어자를 통해 객체를 캡슐화 할 수 있으며, 패키지나 상속관계에 따라 적절하게 사용해야 한다.

### 클래스 변수

모든 객체에서 같은 값을 가지는 속성이 있는 경우, 객체마다 값을 저장하지 않고 클래스 단위에 저장하기 위해 사용한다.

#### 클래스 변수에 접근할 때, '클래스명.클래스변수'의 형식으로 접근해야하는 이유!
1. 클래스 변수는 모든 객체가 공통적으로 가지는 특성 즉, 해당 클래스의 특징을 가지기 때문에 객체참조변수명.클래스변수 형식으로 접근하는 것보다 클래스명.클래스변수 형식으로 접근하는 것이 논리적으로 적절하다.

2. 메모리 구조상 접근 동선이 더 짧다.

![Alt text](<이미지/클래스 변수 접근 과정.png>)