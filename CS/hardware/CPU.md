# CPU
프로그램을 실행하고 데이터를 처리하는 장치로 제어장치, ALU(산술논리연산장치), 레지스터로 구성되어있다. 메모리를 비롯한 다른 장치들과 버스로 연결되어있다.

#### 버스란?
메인보드에 연결된 핵심부품들이 상호간 정보를 주고받는 통로로, 다양한 종류의 버스가 있지만 핵심 부품들은 시스템버스로 정보를 주고 받는다.

#### 시스템 버스
|종류|설명|
|---|---|
|제어버스|동작을 결정하는 제어 정보가 전송|
|주소버스|주기억장치의 주소가 전송|
|데이터버스|동작에 필요한 데이터를 전송|

## 제어장치
프로그램의 명령어를 해석하고 제어 신호(읽기, 쓰기)로 각 장치에 동작을 지시한다.

![Alt text](<이미지/제어장치.png>)

제어장치는 다음 정보들을 받아들인다.
* 클럭: 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
* 명령어: 명령어 레지스터로부터 해석할 명령어를 전달 받음.
* 플래그: 플래그 레지스터로부터 부가 정보를 전달 받음.
* 제어 신호: 주변장치에서 오는 제어 신호를 받음

## ALU
레지스터로부터 피연산자, 제어장치로부터 제어신호를 받아 연산을 수행한다. 연산결과는 레지스터로, 부가정보는 플래그 레지스터로 내보낸다.

![Alt text](<이미지/ALU.png>)

## 레지스터
CPU 내부의 작은 임시저장장치로 명령을 실행하는 동안 필요한 정보를 저장한다.

|종류|설명|
|---|---|
|프로그램 카운터|다음에 실행할 명령어의 주소를 가지고 있다.|
|명령어 레지스터|현재 수행 중인 명령어를 가지고 있다.|
|메모리 주소 레지스터|메모리로부터 읽어오거나 메모리에 쓰기 위한 주소를 가지고 있다.|
|메모리 버퍼 레지스터|메모리로부터 읽어온 데이터 또는 메모리에 써야할 데이터를 가지고 있다.|

![Alt text](<이미지/CPU 실행 흐름.png>)

|종류|설명|
|---|---|
|스택 포인터|주기억장치 스택의 데이터 삽입과 삭제가 이루어지는 주소를 저장한다.|
|플래그 레지스터|연산 결과 또는 CPU 상태에 대한 부가적인 정보를 가지고 있다.|
|베이스 레지스터|변위 주소 지정 방식을 사용하며, 기준 주소를 저장한다.|

> 변위 주소 지정 방식<br>
오퍼랜드(명령어의 피연산자)와 특정 레지스터 값을 더해서 유효주소를 얻는 방식. 특정 레지스터에는 프로그램 카운터와 베이스 레지스터 등이 있다.

#### 실행 흐름
프로그램 카운터에 다음 실행 주소 -> 메모리 주소 레지스터에 복사 -> 주소 버스 -> 메모리 -> 데이터 버스 -> 메모리 버퍼 레지스터에 메모리에 있던 데이터 전달, 프로그램 카운터 값 1 증가 -> 메모리 버퍼 레지스터에 전달 된 값을 명령어 레지스터에 전달

도중에 분기 명령어(JUMP, CALL 등)로 인해 특정 메모리 주소로 실행흐름이 변경될 수도 있다.

# 프로그램 명령어
CPU는 명령어를 하나씩 읽어 프로그램을 실행한다. 인식할 수 있는 명령어의 형식과 종류는 중앙처리장치에 따라 차이가 있지만 보통 연산 코드와 오퍼랜드(피연산자)로 구성된다.

![Alt text](<이미지/프로그램 명령어.png>)

명령어의 종류는 다음과 같다.

## 데이터 전송 명령어
* MOV: 레지스터/주기억장치의 데이터를 레지스터/주기억장치로 전송
* PUSH/POP: 레지스터 <-> 메모리의 스택 사이의 전송

## 연산 명령어
산술 연산과 논리연산, 시프트 연산을 수행한다.

## 분기 명령어
순차적으로 실행되는 명령어를 다른 위치의 명령어로 분기할 수 있다.

* JUMP: 주기억장치의 특정 주소로 분기한 후 돌아오지 않는다.
* CALL: 다른 위치로 잠시 분기했다가 원래 위치로 다시 돌아온다.
* RETURN: CALL 명령어를 통해 분기된 상태에서 함수가 끝났음을 알린다.
* HALT: 프로그램의 실행을 중지한다.

## 입출력 제어
* READ(INPUT): 특정 입출력 장치로부터 데이터를 읽는다.
* WRITE(OUTPUT): 특정 입출력 장치로 데이터를 쓴다.

## 오퍼랜드에 값보다 주소를 저장하는 이유
표현하려는 데이터가 크기의 제한을 받지 않도록 새 주소에 값을 저장하고 오퍼랜드에 해당 주소를 저장한다. 이때 연산에 사용될 데이터가 저장된 주소를 유효주소라고 한다.

### 명령어 주소 지정 방식
* 즉시 주소 지정 방식: 데이터를	오퍼랜드 필드에 직접 명시. 연산에 사용할 데이터의 크기가 작아질 수 있지만 빠르다.
* 직접 주소 지정 방식: 오퍼랜드 필드에 유효 주소 명시, 연산 코드만큼은 크기가 줄어듬.
* 간접 주소 지정 방식: 오퍼랜드에 유효 주소의 주소를 명시. 앞선 방법에 비해 느리다.
    * CPU가 메모리를 뒤적이는 시간은 느리다. 메모리 접근을 최소화해야함.
* 레지스터 주소 지정 방식: 오퍼랜드에 레지스터를 명시.
    * 메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠르다.
* 레지스터 간접 주소 지정 방식: 연산에 사용할 데이터는 메모리에 저장. 데이터가 저장된 메모리 주소는 레지스터에 저장. 이 레지스터를 오퍼랜드에 명시하는 방법.

![Alt text](<이미지/레지스터 간접 주소 지정.png>)

## 명령어 사이클과 인터럽트
### 명령어 사이클
프로그램 속 명령어들이 반복되며 실행되는 일정한 주기

* 인출 단계: 메모리에 저장된 명령어 하나를 읽어 온다.
* 해독 단계: 읽어온 명령어를 제어 정보로 해독한다.
* 실행 단계: 해독된 명령어를 실행한다.

### 인터럽트
정해진 사이클이 중단되는 신호

* 동기 인터럽트(예외): CPU가 예기치 못한 상황을 접했을 때 발생한다. 폴트, 트랩, 중단, 소프트웨어 인터럽트가 있다.

* 비동기 인터럽트(하드웨어 인터럽트): 주로 입출력장치에 의해 발생하며, 문제라기 보다는 알림역할을 한다.

    알림을 주지 않으면 주기적으로 진행사항을 확인해야 하기 때문에 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트를 사용한다.

![Alt text](<이미지/명령어 사이클.png>)

> 간접 사이클<br>
오퍼랜드에 저장된 주소가 유효주소를 가리키는 것과 같이 바로 실행시키지 못하는 경우

#### 인터럽트 처리 순서
1. 입출력장치가 CPU에 인터럽트 요청신호를 보낸다.

2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.

3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 요청을 받아들일 수 있는 지 확인한다.

4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.

5. CPU는 인터럽트 벡터를 참조해서 인터럽트 서비스 루틴을 실행한다.

6. 인터럽트 서비스 루틴 실행이 끝나면 백업해 둔 작업을 복구하여 실행을 재개한다.

처리 흐름: CPU가 인터럽트를 처리 -> 인터럽트 서비스 루틴을 실행 -> 수행하던 작업으로 복귀

> 인터럽트 플래그<br>
인터럽트를 받아들일 수 있는지 표시한다. 표시와 상관없이 막을 수 없는 인터럽트도 있다.<br><br>
인터럽트 서비스 루틴<br>
해당 인터럽트를 처리하기 위한 프로그램<br><br>
인터럽트 벡터<br>
각각의 인터럽트를 구분하기 위한 정보로 인터럽트 서비스 루틴의 시작점을 알 수 있다.<br><br>
인터럽트 발생 시 백업<br>
인터럽트 시점의 프로그램 카운터, 메모리 주소 레지스터, 메모리 버퍼 레지스터, 명령어 레지스터에 있는 값들을 스택 영역에 백업한다.