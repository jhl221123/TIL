# SQL과 DAO의 분리
**변경될 수 있는 텍스트 정보를 외부 리소스로 분리**
* 분리하는 이유: 데이터 접근 로직은 변하지 않더라도 테이블이나 컬럼 명등 SQL 문장이 변할 수 있다.

## 스프링 설정 정보로 분리(Xml)

**스프링 DI를 활용해 DAO 필드로 SQL을 주입**

* 별도의 SQL 서비스에서 SQL을 제공하도록 변경(**DAO에서 로직 분리!**) -> DAO와 관련 없이 수정 가능!
* OXM 기술로 Xml에서 정의한 SQL을 객체로 변환 -> SQL 서비스로 DI
* SQL 서비스의 인터페이스 분리 -> 인터페이스 다중 구현으로 자기 참조빈
  * 원래라면 책임에 맞게 분리하는 것이 좋지만, 책임이 복잡하게 섞여있는 상황에서 역할을 분리하기 좋은 방법!
* 디폴트 설정: 구체 클래스 생성자에서 미리 의존 관계를 지정 -> DI 받으면 수정되지만 기본 생성자와 수정자를 함께 사용하는 방식이라 좋은 방법 같지 않다.

## OXM 서비스 추상화

* JAXB 외, 다른 OXM 기술도 유연하게 적용할 수 있도록 서비스 추상화 이용
* 같은 인터페이스를 구현하고, 구현부도 동일하다면 조합을 사용해서 위임하는 것이 좋다!

## 인터페이스 상속

**기능확정을 위한 인터페이스 상속**

* DI를 잘 사용하는 것보다, DI를 잘 사용할 수 있도록 잘 설계하는 것이 중요하다!
* 등록 인터페이스를 수정가능한 인터페이스로 확장 -> 클라이언트도 의존관계를 변경하지 않아도 된다. -> 결국 확장 가능한 설계 덕분에 유연하게 확장할 수 있는 것!
* 그림 7-11이 잘 설계된 인터페이스의 강점을 제대로 보여주는 사진이라 생각

## SQL 저장 구조, 위치 변경

* 동시성을 고려해 ConcurrentHashMap으로 변경
* 메모리를 사용하기 때문에 IO 부하가 적으면서 DB의 장점을 활용할 수 있는 내장 DB 사용!
  * 인덱스를 활용한 조회 성능 강화(락, 트랜잭션 등)

## 스프링 어노테이션 기반 DI

**어노테이션을 사용하면 리플렉션 API로 메타 정보를 활용할 수 있다.**

* @Configuration으로 설정 정보 생성
  * 수동: @Bean으로 빈 정보 등록
  * 자동: @ComponentScan으로 @Component 빈 정보 자동 등록
* @Import로 설정 정보 가져오기
* @ContextConfiguration으로 설정 정보 등록
* @Profile은 실행 환경에 따른 빈 설정 정보(구성)를 지정
  * 프로파일이 적용된 설정은 빈으로 등록 되어도 활성 프로파일로 지정된 정보만 적용된다.
  * 등록 정보가 많이 없다면 static 클래스를 사용해 관련 정보를 묶는 것도 방법이다.
    * static으로 설정된 @Configuration은 스프링이 자동으로 등록 -> 활성 프로파일에 따라 적용!
