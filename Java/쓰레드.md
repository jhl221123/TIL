# 쓰레드

JVM이 시작되면 자바 프로세스가 시작하며 하나의 프로세스 안에서 여러 쓰레드가 수행된다.

* Runnable 인터페이스와 Thread 클래스를 사용해서 쓰레드를 생성할 수 있다.
두 가지 방식 모두 run() 메소드를 구현해야하며 start() 메소드로 쓰레드를 시작한다.

  ```java
  thread.start(); //Thread 클래스를 확장

  new Thread(runnable).start(); //Runnable 인터페이스를 구현
  ```
  *쓰레드를 실행하려면 위와 같이 Thread 클래스의 인스턴스를 생성해야 하는데 Runnable 구현 방식을 지원하는 이유가 뭘까?*

  자바는 다중 상속이 불가능하기 때문이다. 이미 특정 클래스를 상속받은 클래스의 경우, Thread 클래스를 상속 받을 수 없기 때문에 Runnable 구현 방식을 지원한다.

* 데몬 쓰레드를 제외한 모든 쓰레드가 종료되어야 자바 프로세스가 끝난다.

> 데몬 쓰레드란?<br>
  해당 쓰레드를 실행하기 전 setDaemon() 메소드를 통해 데몬 쓰레드로 설정할 수 있다. 데몬 쓰레드를 제외한 모든 쓰레드가 종료되면 데몬 쓰레드의 진행 여부와 상관없이 프로세스가 종료된다. 주로 부가기능을 수행할 때 사용한다.

자주 사용되는 메소드에 대해 알아보자.

## Thread 클래스가 제공하는 메소드
### sleep()

* 지정한 시간만큼 쓰레드가 대기한다.

### join()

* 해당 쓰레드가 종료될 때까지 기다린다.

* 매개 변수를 통해서 대기 시간을 지정할 수 있다.

### interrupt()
* 수행중인 쓰레드에 중지 요청을 한다.

* sleep(), join(), wait() 메소드가 호출되어 쓰레드가 대기 상태일 경우 유효하며, 쓰레드가 시작하기 전이나 이미 종료된 상태에서는 그냥 넘어간다.

## Object 클래스가 제공하는 메소드
### wait()

* 다른 쓰레드가 notify()나 notifyAll() 메소드를 호출할 때까지 대기한다.

> sleep과의 차이는?<br>
  sleep은 외부 호출 없이 지정된 시간이 지나면 대기 상태가 해제되지만 wait()은 외부에서 notify()를 호출해야 대기 상태가 해제된다.

### notify()와 notifyAll()
* Object 객체의 모니터에 대기하고 있는 쓰레드를 깨운다. 즉, wait() 메소드로 인한 대기 상태를 해제한다.

> 모니터란?<br>
  모니터는 공유 자원과 공유 자원 접근 함수로 이루어져 있으며, wait()와 notify() 메소드와 함께 쓰레드 동기화를 수행한다.

## Thread safe를 위한 synchronized
* 쓰레드를 안전하게 사용하기 위해 제공하는 자바의 예약어로, 메소드에 선언하거나 블록 형태로 특정 문장에만 사용할 수 있다.

* 여러 쓰레드가 동시에 접근하는 경우, 먼저 접근한 쓰레드의 처리가 끝날 때까지 다른 쓰레드의 접근을 제한하는 문지기다.

> StringBuffer와 StringBuilder<br>
  StringBuffer는 주요 데이터 처리부분을 synchronized 블록으로 감싸주었기 때문에 Thread safe 하지만 StringBuilder는 그렇지 않다.

# 쓰레드 로컬

해당 쓰레드만 접근할 수 있는 특별한 저장소로 쓰레드 로컬을 사용해 메소드 호출 시 매개 변수를 넘기지 않고 값을 공유할 수 있으며 동시성 문제를 해결할 수 있다.

> 동시성 문제란?<br>
  여러 쓰레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제로 트래픽이 많을수록 자주 발생한다. 값 변경 없이 읽기만 하거나, 지역 변수를 사용하는 경우에는 동시성 문제가 발생하지 않는다.


아래 그림처럼 두 명의 사용자가 동시에 같은 인스턴스의 필드에 이름을 저장하는 경우 먼저 보관되어 있던 userA는 제거되고 userB가 저장된다.

![Alt text](<이미지/동시성 문제.png>)

이후 userA를 저장한 사용자는 userB를 반환받으며 저장한 값과 조회한 값이 다른 문제가 발생한다.

이런 경우 쓰레드 로컬을 사용하면 쓰레드 전용 저장 공간에 값이 저장되며 동시성 문제를 해결할 수 있다.

![Alt text](<이미지/동시성 문제 해결.png>)


### 자주 사용하는 메소드

|Type|Method|Description|
|---|---|---|
|void|set(T value)|Sets the current thread's copy of this thread-local variable to the specified value.|
|T|get()|Returns the value in the current thread's copy of this thread-local variable.|
|void|remove()|Removes the current thread's value for this thread-local variable.|


## 쓰레드 로컬 사용 시 주의사항
쓰레드 로컬을 사용한 후, ThreadLocal.remove()를 호출해서 쓰레드 로컬에 저장된 값을 제거해 주어야 한다.

단일 쓰레드 환경에서는 수행이 끝나면 해당 쓰레드가 사라지지만 WAS의 경우 쓰레드 생성 비용이 비싸기 때문에 사용이 끝난 쓰레드는 풀에 반환된다. 이때 쓰레드 로컬을 제거하지 않으면 다음 클라이언트가 해당 쓰레드를 사용할 때 쓰레기 값이 들어있게 된다. 이런 문제를 예방하기 위해 요청 처리가 끝나고 반드시 쓰레드 로컬을 제거해야 한다.