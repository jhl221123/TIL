# 객체지향의 5대 원칙 SOLID

**객체지향 설계를 위해 많은 시행착오 끝에 만들어진 원칙**

* 좋은 설계는 낮은 결합도와 높은 응집도를 가진다.
* 결합도가 낮으면 유연하고 재사용하기 좋다.
* 응집도가 높으면 필요한 책임만을 가지고, 올바른 역할을 수행할 수 있다.
* 두 가지 조건을 만족하는 설계는 변경의 파급효과가 적어 유지보수하기 좋다.

## 단일 책임의 원칙(SRP)

**변경해야 하는 이유는 하나여야 한다.**

* 객체가 너무 많은 역할과 책임을 가지고 있다는 것은 결합도가 높고 응집도가 낮다는 의미다.
* 추상화를 통한 모델링 과정에서 역할에 맞는 책임만 가지도록 설계해야 한다.
* 설계 상황과 문맥에 따라 책임의 크기가 다를 수 있기 때문에 변경의 파급효과를 고려해 적절하게 구분하는 것이 중요하다.

## 개방 폐쇄 원칙(OCP)

#### 확장에는 열려있고 변경에는 닫혀있어야 한다.

* 확장하기 쉽지만, 확장으로 인해 변경되는 부분이 없도록 설계해야 한다.
* JDBC에서 DB 종류를 변경해도 기존 코드를 수정할 필요가 없는 부분이 대표적이 예시다.
* 객체지향의 가장 큰 장점인 유연성과 유지보수성을 얻기 위해서는 OCP 원칙을 지켜야 한다.

## 리스코프 치환 원칙(LSP)

**하위 클래스의 인스턴스는 상위 클래스의 인스턴스의 역할을 수행할 수 있어야 한다.**

* 상속을 **분류**의 개념으로 올바르게 사용한다면 자연스럽게 해당 원칙을 지킬 수 있다.
* 반면, 상속을 **조직도 또는 계층 구조**의 개념으로 사용한다면 해당 원칙을 위반할 수 있다.
* 상위 분류가 제공하는 물리적, 논리적 규약을 모두 지켜야만 신뢰하고 사용할 수 있다.

```java
동물 호랑이 = new 호랑이(); // 분류

할아버지 아버지 = new 아버지(); // 계층

동물 호랑이 = new 호흡을 할 수 없는 호랑이(); // 동물 역할을 수행할 수 없다.
```

## 인터페이스 분리 원칙(ISP)

**클라이언트는 사용하지 않는 메서드에 의존해서는 안 된다.**

* SRP와 같은 문제를 다른 방식으로 해결한다.
* 많은 책임을 가진 클래스를 분리하는 것이 아니라, 역할에 따라 구분해서 사용한다.
* 구분하는 과정에서 역할에 맞는 최소한의 메서드만 제공하도록 해야 한다.

![Alt text](<이미지/ISP 두 가지 역할의 인터페이스.png>)

**인터페이스는 적은 기능을 제공할수록, 상위 클래스는 많은 기능을 제공할수록 좋다.**

* 상위 클래스에서 제공하는 기능이 적다면, 공통 요소를 올바르게 처리하지 못할 수 있다.
* 이 경우, 공통 요소에 대한 책임을 하위 클래스가 가지게 되고, 상속의 혜택을 온전히 누리지 못하게 된다.

## 의존관계 역전 원칙(DIP)

**구체적인 것에 의존하지 말고 추상화에 의존하라.**

* 구체적이고 자신보다 변하기 쉬운 것에 의존하면, 변경에 영향을 받게 된다.
* DIP를 지키기 위해 제 3의 역할을 이용하는 과정에서 의존관계가 역전된다.
* OCP와도 밀접한 관계를 가진다.