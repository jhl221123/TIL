# 해시(Hash)
임의의 길이를 갖는 데이터를 고정된 길이의 데이터로 변환하는 것으로 객체를 식별하는 하나의 정수값을 의미한다.

## equals() 메소드를 재정의하면 왜 hashCode() 메소드도 재정의 해야할까?

해시를 사용하는 HashSet, HashMap, HashTable을 사용할 때 문제가 발생하기 때문이다.

![Alt text](<이미지/해시 자료구조.png>)

해시를 사용하는 컬렉션들은 해시함수를 사용해서 키를 해시값으로 매핑한다. hashCode() 메소드를 재정의하지 않으면 다음 두 가지 문제가 발생한다.

### 논리적으로 동일한 객체에 대한 중복을 구분하지 못한다.

hashCode() 메소드는 재정의 하지 않으면 객체의 실제 메모리 번지를 이용해서 해시를 만든다. 따라서 equals() 메소드만 재정의하게 되면 논리적으로는 동등하지만 다른 해시를 가지게 되고 해당 컬렉션은 이를 다른 객체로 인식한다.

### 재정의를 통해 해시 충돌을 방지

동일한 키 값에 다른 값이 저장되는 해시충돌이 발생할 수 있으며, 이로 인해 성능 저하가 발생한다.
자바는 실제 객체의 주소값 대신 해시함수를 통해 해시코드를 사용한다. 보통 주소값이 다르면 같은 해시코드를 가질 수 없다. 하지만 입력 데이터의 개수가 해시 코드의 개수보다 많을 경우, 해시 충돌이 발생할 수 있다.

```java
public class Object {

    public native int hashCode();
}
```

# 해시 충돌

컴퓨터가 32bit 사양이라면 해시코드의 범위와 동일하기 때문에 상관없지만 대부분 사용하는 64비트 컴퓨터에서 돌아가는 JVM은 기본적으로 8바이트 주소체계를 기본으로 하기 때문에 이 범위의 차이로 인해 값이 겹칠수도 있다. (이를 Hash Collisions 해시충돌이라 일컫는다)

> 해시 함수는 입력 데이터를 해시 코드로 변환하는 함수로, 해시 함수의 목적은 입력값의 고유한 해시 코드를 생성하는 것이다. 해시 함수의 출력 범위가 입력 데이터의 개수보다 작으면 해시 충돌이 일어난다.

해시충돌이란?
해시 함수가 서로 다른 입력값에 대해 동일한 해시 코드를 생성하는 상황을 말한다. 해시 자료구조의 경우 다른 키를 저장했는데 hashCode() 메소드 결과가 같은 경우다. JVM의 주소체계에 따라 이런 문제가 발생할 수 있다.

32bit 컴퓨터의 경우, JVM은 4바이트 주소체계를 가지며 해시코드의 반환타입인 int와 크기가 동일하다.
```
hashCode() 메서드는 int형 정수를 반환한다.
```
반면 64bit 컴퓨터의 경우, JVM은 8바이트 주소체계를 가지는데 해시코드의 반환타입인 int로는 모든 주소값을 중복 없이 표현할 수 없다. 이런 이유로 해시 충돌이 발생한다.

JAVA의 해시충돌 해결 방법
해시 자료구조의 경우 보통 객체를 비교할 일이 생길경우, 두 객체의 해시 코드가 같으면 바로 equals() 메서드로 비교해서 동일한 객체를 찾기 때문에 Object 클래스의 hashCode() 와 equals() 메서드를 잘 구현했다면 충돌을 피할 수 있다.

### 해시비교 후 equals() 적용 과정
해시 충돌로 인해 동일한 버켓에 여러 개의 값이 들어 있는 경우 equals() 메소드를 호출해 동일한 값을 찾는다.

버켓과 sort그림.png

이 때 해당 버킷의 슬롯이 충분하다면 저장이 모두 가능하고, 충분하지 않으면 오버플로우가 발생한다. 이러한 충돌과 오버플로우를 해결하기 위한 방법은 크게 Chaining과 Open Addressing이 있다.

#### 체이닝
체이닝은 슬롯을 연결리스트와 같이 공간의 제한이 없는 구조를 사용하여 같은 버킷을 해시되는 데이터들을 모두 저장하는 방법이다.

#### 개방 주소법
개방 주소법은 충돌발생 시 해시 테이블 영역 내의 다른 빈 공간을 찾아 저장하는 방식이다. 대표적으로 선형조사법이 있다.

> 선형 조사법이란 해시 테이블을 1차원 배열로 보고 충돌 발생 시 가까운 빈 슬롯에 저장하는 것이다.