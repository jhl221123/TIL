# Java의 스레드 동기화

## synchronized

동기화를 위해 자바에서 제공하는 예약어로 임계 영역에 다수의 스레드가 접근할 때, 한 번에 하나의 스레드만 접근할 수 있도록 제한한다. 먼저 접근한 스레드는 lock을 얻고 처리해야할 작업을 수행하며, 작업을 완료한 후에 lock을 반환한다. 메서드 단위로 사용하거나 원하는 위치에 블록으로 지정해서 사용할 수 있다.

다만, lock을 생성하고 해제하는 작업에서 성능 저하가 발생할 수 있으며, 잘못된 순서로 해제할 경우 교착 상태에 빠질 수 있다. 따라서 동기화 작업이 필요하다면 java.util.concurrent 패키지에서 제공하는 기능을 사용하자.

## Lock

java.util.concurrent.locks 패키지에서 제공하는 인터페이스로 synchronized를 사용한 동기화 처리보다 유연하게 사용할 수 있다.

```java
 Lock l = ...;
 l.lock();
 try {
   // access the resource protected by this lock
 } finally {
   l.unlock();
 }
```

다음과 같은 기능들을 제공한다.

### lock()

lock을 획득하는 메서드로 lock을 사용할 수 없는 경우, 스케줄링 목적으로 비활성화되고 lock을 획득할 때까지 휴면 상태가 된다.

### tryLock()

호출 시점에 lock을 사용할 수 있는 경우에만 획득한다. lock을 사용할 수 있는 경우에는 true, 사용할 수 없는 경우 false를 반환하며 아래와 같이 사용한다.

```java
Lock lock = ...;
 if (lock.tryLock()) {
   try {
     // 임계 영역
   } finally {
     lock.unlock();
   }
 } else {
   // lock 획득 실패 시 전략
 }

```

대기 시간을 지정해서 해당 시간만큼 lock을 기다릴 수도 있으며, 지정된 시간을 초과하면 더 이상 lock을 기다리지 않는다.

### lockInterruptibly()

lock을 사용할 수 있는 경우 lock을 획득하고, lock을 사용할 수 없는 경우 비활성화된다. 단, 외부에서 interrupt() 메서드를 호출해서 더 이상 lock을 기다리지 않을 수 있다.

## concurrentHashMap

스레드의 접근을 제한하는 방식이 아니라 CAS(Compare And Swap)를 사용한 원자적 연산과 volatile을 사용한 메모리 가시성 확보를 통해 스레드를 동기화한다.

### CAS와 연산의 원자성

CAS는 연산의 원자성을 보장하기 위한 알고리즘으로 현재 메모리의 값이 기대하는 값과 다르다면 작업을 수행하지 않는다.

예를 들어 *i++;* 는 네 가지 동작으로 구분할 수 있다.

1. 변수 i의 값을 메모리에서 읽어 캐시에 저장한다.

2. 캐시의 값에 1을 더한다.

3. 더한 값을 캐시에 저장한다.

4. 캐시에 저장된 연산 결과를 메모리에 저장한다.

멀티 스레드 환경에서 하나의 스레드가 연산 결과를 메모리에 저장하기 전에 다른 스레드가 메모리의 값을 캐시로 가져간다면 연산의 무결성이 깨지게 된다. 위의 네 과정을 원자처럼 더이상 분리하지 못하도록 하는 것이 연산의 원자성을 보장하는 것이다.

하지만 연산의 원자성만 보장한다고 동기화 처리가 되는 것은 아니다.

### volatile과 메모리 가시성

멀티 스레드 환경에서 공유 변수 접근 시, JIT 컴파일러가 캐시를 활용해 내부적으로 최적화 작업을 수행한다. 이로 인해 각 스레드는 연산과정에서 실제 메모리가 아니라 캐시에 저장된 값을 사용하기 때문에 연산의 무결성을 보장하지 못하게 된다.

자바의 volatile은 JIT가 최적화 작업을 수행하지 않게 함으로써, 연산과정에서 캐시가 아닌 실제 메모리에 바로 접근하도록 한다. 이를 통해 멀티 스레드 환경에서 메모리 가시성을 확보할 수 있게 된다.

concurrentHashMap은 수정 작업에서 이미 노드에 값이 존재하는 경우에만 synchronized를 사용하고, 노드에 값이 없거나 조회하는 경우에는 volatile과 CAS 연산을 활용해 최소한의 lock 사용으로 스레드 안정성을 보장한다.